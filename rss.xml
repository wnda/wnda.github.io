<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[A. M. Douglas · Full-stack Web Developer · Leeds, UK]]></title><description><![CDATA[I'm a freelance web developer, web development consultant and strategist. I make clean, modern websites and web apps with a focus on performance, security and accessibility. Let's talk!]]></description><link>https://amdouglas.com/</link><generator>AMD 1.0.5</generator><lastBuildDate>Fri, 30 Sep 2016 23:32:46 GMT</lastBuildDate><atom:link href="https://amdouglas.com/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Asynchronous CSS: the easy way]]></title><description><![CDATA[<p>If you've ever looked into asynchronously handling fonts, you've probably read about FilamentGroup's method:</p>

<pre><code>&lt;link rel=preload href=/assets/css/main.css as=style onload=this.rel=stylesheet;this.type=text/css;&gt;
</code></pre>

<p>It might look like a hack, but this is actually what the <code>link rel=preload</code> spec</p>]]></description><link>https://amdouglas.com/asynchronous-css-the-easy-way/</link><guid isPermaLink="false">76e850d7-d6dd-4efa-a7df-96b5e242a0ad</guid><category><![CDATA[javascript]]></category><category><![CDATA[css]]></category><dc:creator><![CDATA[A. M. Douglas]]></dc:creator><pubDate>Tue, 20 Sep 2016 21:39:52 GMT</pubDate><content:encoded><![CDATA[<p>If you've ever looked into asynchronously handling fonts, you've probably read about FilamentGroup's method:</p>

<pre><code>&lt;link rel=preload href=/assets/css/main.css as=style onload=this.rel=stylesheet;this.type=text/css;&gt;
</code></pre>

<p>It might look like a hack, but this is actually what the <code>link rel=preload</code> spec is intended for.</p>

<p>The problem is that this will do absolutely nothing in browsers which do not support <code>link rel=preload</code>, and that is a non-trivial number of browsers. You also can't just stick your stylesheet in a <code>noscript</code> element and hope for the best.</p>

<p>FilamentGroup offers a <a href="https://github.com/filamentgroup/loadCSS">big solution</a> which obviously works well, but I think I prefer a rather more simple approach.</p>

<pre><code>var inertCSS = document.querySelectorAll( '[rel="preload"][as="style"]' ),
        i    = inertCSS.length;

    if ( !!inertCSS )
    {
      while ( i-- )
      {
        var css  = document.createElement( 'link' );
        css.rel  = 'stylesheet';
        css.href = inertCSS[i].href;
        ( document.head || document.getElementsByTagName( 'head' )[0] ).appendChild( css );
      }
    }
</code></pre>

<p></p><p>My solution isn't bulletproof. You still need <code>querySelectorAll</code> and you'll need to be careful that you check for unloaded CSS on the <code>DOMContentLoaded</code> event—otherwise, you run the risk of loading your stylesheet(s) twice.</p>]]></content:encoded></item><item><title><![CDATA[Stripe Custom Form in vanilla JavaScript]]></title><description><![CDATA[<p>Given that it's January and nobody seems to have any money, there obviously couldn't be a less appropriate time to think about adding or customising an e-commerce experience with your own take on <a href="https://stripe.com" title="Stripe Payment Gateway">the Stripe form</a>.</p>

<h4 id="beforeyougoanyfurther">Before you go any further</h4>

<p>This article will be pretty long, as I will</p>]]></description><link>https://amdouglas.com/stripe-custom-form-in-vanilla-js/</link><guid isPermaLink="false">e5421570-4e72-466b-bae7-3669c4eb7ef5</guid><category><![CDATA[javascript]]></category><category><![CDATA[ajax]]></category><dc:creator><![CDATA[A. M. Douglas]]></dc:creator><pubDate>Tue, 20 Sep 2016 21:38:34 GMT</pubDate><content:encoded><![CDATA[<p>Given that it's January and nobody seems to have any money, there obviously couldn't be a less appropriate time to think about adding or customising an e-commerce experience with your own take on <a href="https://stripe.com" title="Stripe Payment Gateway">the Stripe form</a>.</p>

<h4 id="beforeyougoanyfurther">Before you go any further</h4>

<p>This article will be pretty long, as I will narrate the general process of responsibly creating forms in general, so if you a skip-to-the-end kind of person, you can find the <a href="https://github.com/wnda/stripe-custom">source code here</a> and the <a href="https://amdouglas.com/pay">live payment form here</a>.</p>

<p>Please also note that I will be demonstrating the server-side controller for a custom Stripe form in a hypothetical <strong>Node/Express</strong> web application using vanilla JavaScript on the front-end. So, if you like jQuery, or if you are just looking for an API reference for a Ruby, PHP or Go app, you can find official documentation <a href="https://stripe.com/docs/tutorials/forms">about</a> <a href="https://stripe.com/docs/api">both</a> at the Stripe website.</p>

<p>Finally, if you're a Perl developer, I may in the future do a write-up on implementing Stripe with Perl, but for the moment I'm waiting to see whether it will be Perl 5 or Perl 6 that I will be using for that.</p>

<h4 id="sowhyacustomform">So, why a custom form?</h4>

<p>You might ask why anybody would want to do this, since the Stripe payment widget loaded via iFrame is a pretty damn well-engineered piece of kit, helps you circumvent an otherwise expensive PCI Compliance audit, and saves you the trouble of styling your payment form.</p>

<p>Here are the reasons I wanted to create a customised experience:</p>

<ul>
<li><p>The default Stripe Checkout widget does not support variable payment amounts</p></li>
<li><p>It's also widget is kind of heavy</p></li>
<li><p>It looks great, like it was plucked out of OS X, but the gradients and solid theme might clash with your website/app's UI (as it does with mine)</p></li>
<li><p>You may just want an exercise with your afternoon tea</p></li>
</ul>

<h3 id="preamblewhystripe">Preamble: why Stripe?</h3>

<p>Stripe is an innovative piece of kit, primarily because of how easy it is to work with for developers like myself&mdash;and also for its simple pricing model. Granted, it's not the cheapest, but what you lose in the slightly higher transaction fees is more than compensated by the removal of headaches. </p>

<p>Considering other payment gateways offering easy PCI Compliance, SagePay's iFrame is a trusty mule, but it's a bit ugly, and implementing a customised experience is not as easy. You also need a merchant account and you need to pay a flat fee of £25 per month, so Stripe's model of paying more, but only when you use their service, is instantly more attractive to startup companies and fledgling freelancers.</p>

<p>Paypal I do not even consider these days unless it's specifically requested by a client, and even then, I just try to persuade them of the benefits of Stripe or SagePay. Paypal is simple to setup, but presents one of two unpleasant issues.</p>

<ul>
<li>Either you use a generic button, direct the customer to Paypal and implement an IPN listener or</li>
<li>Credit card info gets passed to your server at some point&mdash;bye bye PCI Compliance. </li>
</ul>

<p>Perhaps the most important advantage Stripe offers is the pleasantly surprising policy on international transactions and American Express: no additional fees are levied, making it a very good idea for businesses targeting multiple countries.</p>

<p>A final benefit: Stripe is one of the few payment gateways who will migrate your subscribers (should you have subscribers) to an alternative provider on your behalf.</p>

<h4 id="prerequisites">Prerequisites</h4>

<ul>
<li>A text editor
<ul><li>yes, there is a best one: the one you like to use.</li></ul></li>
<li>A web browser
<ul><li>yes, there is a best one, but you can't assume that your customers will use it&mdash;so build in whatever browser you normally use.</li></ul></li>
<li>A server with a web application
<ul><li>This tutorial uses a Node/Express app to demonstrate Stripe integration.</li></ul></li>
<li>An SSL certificate and an encrypted connection to your web application
<ul><li>at least for your payment page, but there's really no reason not to force SSL across your website unless you use subdomains instead of directory routes.</li></ul></li>
</ul>

<h4 id="gettingstarted">Getting started</h4>

<p>A mistake many developers make is that they think <strong>Stripe</strong> is an entirely client-side solution to the problem of payments, and are suddenly overwhelmed to discover that some server-side logic must be established to fulfil the payments that are only initiated by the client-side library. Fortunately, the Stripe team provide robust server-side libraries as well.</p>

<p>Creating a custom form really couldn't be much simpler, but for those who prefer to have some actual instructions on implementation, the client-side code is only provided with a strong dependence on jQuery and for fixed-amount payments. jQuery is a truly great library and, for a long time, most developers would have been foolish not to leverage its cross-browser compatibility features. </p>

<p>Now we're in 2016, the issue of cross-browser JavaScript portability is no longer critical (as long as you don't care about IE8&mdash;which you shouldn't since even Microsoft has officially discontinued support for it) jQuery represents little more than needless overheard. Some things are still simpler to do, sure, but the cost to operations per second is no longer justified, especially not on mobile.</p>

<p>Given that we want to allow our customer to pay-what-they-want, and given that we also do not want to use a needless and arguably heavy library, we will need to come up with our own variation. Fortunately, the JavaScript code doesn't really look much different to the jQuery code in the end until you reach the point where you want to interrupt the form submission and subsequently XHR the form to your server along with the StripeToken.</p>

<p>Let us begin by understanding what Stripe does.</p>

<h4 id="howstripeworks">How Stripe works</h4>

<p>Stripe helps developers and businesses avoid headaches about PCI compliance by preventing sensitive data from ever touching the vendor's server. The data is handled by Stripe's iFrame which returns a one-way encrypted token by which transactions are identified and processed by server-side business logic. Beautiful and simple to work with.</p>

<p>Perhaps the real beauty, however, is in the flexibility of the Stripe payment gateway. You have two options. Firstly, there's <strong>Stripe Checkout</strong>, which loads a widget in an iFrame much like SagePay's form integration solution, though a good deal prettier. Secondly, there's <strong>Stripe.js</strong>, which gives you the power to implement your own payment form while still levying the <strong>Checkout</strong> widget's strengths&mdash;like the validator functions, which very reliably check the authenticity of credit card numbers on the client-side (enabling good UX) while at the same time not checking those numbers against anything on your server.</p>

<p>Stripe.js is designed to intercept your payment form, pass the credit card details to Stripe's servers, process the payment and return a token which is used to authorise the payment and charge the card from your web application. </p>

<h4 id="thepaymentform">The Payment Form</h4>

<p>Yes, unsurprisingly, the first thing we need is a payment form. It will initially look something like this:</p>

<pre><code>&lt;form method="POST" action="/pay-controller"&gt;
  &lt;fieldset&gt;
    &lt;div class="field"&gt;
      &lt;label&gt;
        &lt;input type="email" id="email"&gt;
      &lt;/label&gt;
    &lt;/div&gt;
  &lt;/fieldset&gt;
  &lt;fieldset&gt;
    &lt;div class="field"&gt;
      &lt;label&gt;
        &lt;input type="text" id="card-number"&gt;
      &lt;/label&gt;
    &lt;/div&gt;
    &lt;div class="field"&gt;
      &lt;label&gt;
        &lt;input type="text" id="cvc-number"&gt;
      &lt;/label&gt;
    &lt;/div&gt;
    &lt;div class="field"&gt;
      &lt;label&gt;
        &lt;input type="text" id="exp-month"&gt;
      &lt;/label&gt;
    &lt;/div&gt;
    &lt;div class="field"&gt;
      &lt;label&gt;
        &lt;input type="text" id="exp-year"&gt;
      &lt;/label&gt;
    &lt;/div&gt;
  &lt;/fieldset&gt;
  &lt;button type="submit" class="btnpay"&gt;Pay&lt;/button&gt;
&lt;/form&gt;
</code></pre>

<p>You could have a more bare-bones form, but chances are you'll end up using <code>div</code> elements to give you control over the <code>input</code> sizing and layout. You may also have noticed the fact that I am wrapping <code>input</code> fields in <code>labels</code> rather than the arguably preferable use of the <code>for=</code> attribute on <code>labels</code>. This is, however, a necessity, as we shall see shortly.</p>

<p>The <code>form</code> <code>action</code> is left blank in a lot of Stripe's examples, but you want to point this to the route of your controller which is going to charge the credit card.</p>

<p>So, when the customer fills out this form, we need to pass the credit card details to Stripe, receive the Stripe token and then resubmit the form including the token. This is pretty straightforward if you've ever used a <code>POST</code> request to pass url-encoded data to a server via <code>XMLHttpRequest</code> before. For those of you who have not, I will cover it extensively so fear not.</p>

<p>Before we go any further, however, we need to change this form a little. We obviously want to validate the form on the client-side for a good user experience, though Stripe itself will validate any payment sent to its API for processing, and we will obviously include server-side validation as well. We want the price to be flexible (but greater than 0) and let's say that we want the customer's email address as well so we can mail out basic payment confirmation message. Our form then should look more like this:</p>

<pre><code>&lt;form method="POST" action="/pay-controller"&gt;
  &lt;fieldset&gt;
    &lt;div class="field"&gt;
      &lt;label&gt;
        &lt;input type="email" id="email" name="email" required&gt;
      &lt;/label&gt;
    &lt;/div&gt;
    &lt;div class="field"&gt;
      &lt;label&gt;
        &lt;input type="number" id="price-gbp" pattern="[1-9]\d*" required&gt;
      &lt;/label&gt;
      &lt;input type="hidden" id="price-pennies" name="amount"&gt;
    &lt;/div&gt;
  &lt;/fieldset&gt;
  &lt;fieldset&gt;
    &lt;div class="field"&gt;
      &lt;label&gt;
        &lt;input type="text" id="card-number" pattern="[0-9]{13,16}" maxlength="16" required&gt;
      &lt;/label&gt;
    &lt;/div&gt;
    &lt;div class="field"&gt;
      &lt;label&gt;
        &lt;input type="text" id="cvc-number" pattern="[0-9]{3,3}" maxlength="3" required&gt;
      &lt;/label&gt;
    &lt;/div&gt;
    &lt;div class="field"&gt;
      &lt;label&gt;
        &lt;input type="text" id="exp-month" pattern="0[1-9]|1[012]" maxlength="2" required&gt;
      &lt;/label&gt;
    &lt;/div&gt;
    &lt;div class="field"&gt;
      &lt;label&gt;
        &lt;input type="text" id="exp-year" pattern="[0-9]{4,4}" maxlength="4" required&gt;
      &lt;/label&gt;
    &lt;/div&gt;
  &lt;/fieldset&gt;
  &lt;button type="submit" class="btnpay"&gt;Pay&lt;/button&gt;
&lt;/form&gt;
</code></pre>

<p>HTML5 <code>input</code> elements have come a long way, but there is still some inconsistency in which attributes really work in terms of validation. The most effective ones I have tested are <code>required</code> (obvious), and <code>pattern</code>&mdash;which allows you to supply a regular expression to test the <code>input</code> values entered by the customer, without JavaScript and in real-time, without additional libraries and event listeners. That said, in production you will want something more robust which will block form submission in browsers which do not honor the <code>required</code> or <code>pattern</code> attributes.</p>

<p>Note how there is now <code>pattern</code> attribute specified for the <code>input type="email"</code>&mdash;this is because the email type automatically feeds this field with an implicit pattern which is more effective and reliable than any regular expression you could supply in a pattern attribute. The same applies to the <code>number</code> type <code>input</code>, which will not accept letters and will prompt mobile users with the number keypad rather than the keyboard. </p>

<p>Personally, I don't consider this good user experience (text <code>input</code> is always nicer to use) but for the sake of making things easier a bit later, we'll roll with this for now. <a href="http://html5pattern.com/Miscs" title="HTML5 input regex validation patterns">If you want price formatting, there are some good patterns available at html5pattern.com</a>.</p>

<p>The other <code>input</code> fields have been fielded with patterns and max-lengths to prevent 60-character CVCs&mdash;which can be confusing for the user, since some gauge the validity of their own responses according to when the input fields restrict further input. You might wonder why I am not specifying a <code>minlength</code> attribute&mdash;this is because <a href="http://caniuse.com/#search=minlength">support for <code>minlength</code> is limited to Chrome and other Blink-based web browsers</a>, whereas <a href="http://caniuse.com/#search=pattern">support for <code>pattern</code> is remarkably good</a>. Patterns are elegant because they allow you to validate both format and length, but we still specify <code>maxlength</code> because:</p>

<ul>
<li>support for <code>maxlength</code> is all but universal</li>
<li><code>pattern</code> does not restrict how long an entry can be in an input field, where <code>maxlength</code> does in most browsers</li>
</ul>

<p>The whole point of these validation attributes rather than just importing a massive library? Firstly, to optimise for the future. One day, support will be comprehensive and the need for downloading a couple of form validation libraries will be a distant memory. Secondly, Stripe.js will perform the critical validations when we interrupt the form's submission.</p>

<p>Finally, note where <code>name</code> attributes have been included and where they have not. If you've worked with forms before, you will know that <code>input</code> elements specifying a <code>name</code> will supply their input values as url-encoded data in the <code>HTTP POST</code> ready to be retrieved by your server. We want to catch the price entered by the customer, as well as their email address, so we give these input fields appropriate names. Crucially, we do not give names to the input fields which will bear credit card data, as this would cause that data to be posted to your server and our mission to achieve easy PCI compliance would fail rather abruptly.</p>

<h4 id="theimport">The Import</h4>

<p>Now we have a form, we can start building the application code. First, before anything else and probably best in the <code>&lt;head&gt;</code>, import the Stripe.js client-side library and immediately after set your publishable key.</p>

<pre><code>&lt;script src="https://js.stripe.com/v2/"&gt;&lt;/script&gt;
&lt;script&gt;
    Stripe.setPublishableKey('YOUR_PUBLISHABLE_KEY');
&lt;/script&gt;
</code></pre>

<p>Not much to say about this, except that nothing will work without it.</p>

<h4 id="theintercept">The Intercept</h4>

<p>So, now we have an <code>input</code> ready to supply us with a price, we need to write the JavaScript to interrupt this form. There are two commonly used methods to interrupt form submission using JavaScript: <code>preventDefault</code> and <code>return false</code>. You will find many StackOverflow answers claiming that <code>return false</code> will cancel both the default event and event propagation through parent element event listeners, but this applies to <strong>jQuery</strong> events only. In vanilla JavaScript, the story is different. <code>preventDefault</code> successfully prevents the default event (as its name would suggest) while <code>return false</code> prevents neither the event nor propagation. To see the difference, here are two examples to compare: <a href="https://output.jsbin.com/rejili/">Vanilla JavaScript</a> vs <a href="http://jsfiddle.net/jonathon/xty5c/">jQuery</a>. However, when it comes to interrupting form submissions, the two are still more or less interchangeable&mdash;but I strongly advise the use of <code>preventDefault</code> given that it is 2016 and all.</p>

<pre><code>&lt;script&gt;
    function stripeResponseHandler(status,response){
      "use strict";
      var paymentForm=document.forms['payform'];
      if (response.error) {
        document.getElementById('feedback').textContent=response.error.message;
        document.getElementById('btnpay').removeAttribute('disabled');
      }
          else
      {
        var dataAmount=document.getElementById('amount');
        var dataEmail=document.getElementById('email');
        var stripeToken=response.id;
        var formString="amount="
            + dataAmount.value
            + "&amp;stripeToken="
            + stripeToken
            + "&amp;email="
            + dataEmail.value;

        function submitForm(f){
          var xhr=new XMLHttpRequest();

          xhr.onload=function(){
            window.location=xhr.responseText;
          }

          xhr.onerror=function(){
            document.getElementById('feedback').textContent="Error";
            console.log(xhr.responseText);
          }
          xhr.open(paymentForm.method,paymentForm.action,true);
          xhr.setRequestHeader('Content-type','application/x-www-form-urlencoded');
          xhr.send(f);
        }

        return submitForm(formString);
      }
    }

  !function(){
    "use strict";
    var paymentForm=document.forms['payform'];

    paymentForm.addEventListener('submit',function(e){
      e.preventDefault();
      var thisForm=this;
      document.getElementById('btnpay').setAttribute('disabled',true);
      var baseAmount=document.getElementById('amountbase').value | 0;
      var amountField=document.getElementById('amount');

      function pound(a){
          return a * 100;
      };

      amountField.value=pound(baseAmount);
      if (amountField.value&gt;0) {
          Stripe.card.createToken(thisForm,stripeResponseHandler);
      }
          else
      {
        alert('Please enter a payment amount');
        document.getElementById('btnpay').removeAttribute('disabled');}
    });
  }();
&lt;/script&gt;
</code></pre>

<p>That's probably enough for Part 1. Stay tuned for part 2!</p>]]></content:encoded></item><item><title><![CDATA[Lazyloading CSS background-images]]></title><description><![CDATA[As a rule, I generally prefer, for the purposes of accessibility and SEO, to use IMG elements to display images over the background-image approach...]]></description><link>https://amdouglas.com/lazyloading-css/</link><guid isPermaLink="false">b459c1dc-428b-435a-ac70-802c1a45d375</guid><category><![CDATA[javascript]]></category><category><![CDATA[css]]></category><dc:creator><![CDATA[A. M. Douglas]]></dc:creator><pubDate>Sun, 21 Aug 2016 21:35:00 GMT</pubDate><content:encoded><![CDATA[<p>As a rule, I generally prefer, for the purposes of accessibility and SEO, to use <code>IMG</code> elements to display images over the <code>background-image</code> approach. However, getting an image to display in a certain way — say, in such a way that it expands to fill a given space while maintaining aspect ratio — is not a trivial matter, and the solution (much the same as <a href="https://amdouglas.com/useful-css-tricks/">my prior demonstration of making a video background</a>) raises some concerns for users of older browsers.</p>

<p>While not conceptually difficult, it is also more time-consuming and potentially buggy to implement as opposed to the obvious answer: <code>background-size: cover</code> (which is equivalent to <code>background-size: auto 100%</code>, if you were wondering). CSS background images offer a very convenient and malleable way to display images, and if you don&rsquo;t care about your images being picked up by screen readers and Google Image Search, why not use them?</p>

<p>Well, it might also appear to be a bit of a bummer that most prêt-à-porter image lazy-loading snippets/&lsquo;plugins&rsquo; are intended for loading <code>IMG</code> elements. I&rsquo;m not sure why this is the case, since it seems straightforward to lazy-load a background-image by applying it as an attribute style, having retrieved the image source from, say, a <code>data-</code> attribute.</p>

<p>Since I couldn&rsquo;t find a JS lib that would do both, I rolled my own, which I called toad because it leaps into action (and because toad rhymes with load, obviously). The key to creating a library to do both is to test whether an image source should be cloned to the <code>src</code> attribute or as a background-image in an attribute style.</p>

<p>The easiest way to discern whether you need to apply a <code>background-image</code> style is to test the element in question and see if it&rsquo;s an <code>IMG</code> element. Your function to test for this might look like this:</p>

<pre><code>function isImg( element ) {
  if ( !element || el.nodeType !== 1 ) return false;

  if ( el.tagName !== "IMG" ) return false;

  return !el.src;
}
</code></pre>

<p>First, make sure you have a something. Make sure it&rsquo;s a valid element while you&rsquo;re at it. Then make sure it&rsquo;s an <code>IMG</code> element. And finally, may as well test to see if the image has already been loaded and send that down as the boolean that will decide ultimately whether you lazy-load or not.</p>

<p>It&rsquo;s also important, however, to make sure you don't overwrite the background-images you've already set. To do this, we want to loop through the element&rsquo;s style attribute and check if background-image is anywhere in there. This is all we need to check, because if <code>background</code> is set using the short-hand, it will overwrite the background-image anyway.</p>

<p>Once you&rsquo;ve discerned how to load the image, you need to make sure that if an element already has a source, be it <code>src</code> or <code>url()</code>, you need to remove that element&rsquo;s <code>data-</code> attribute. This will prevent your lazy-loader from firing when it does not need to.</p>

<p>Finally, something you should definitely have is a means of throttling the <code>scroll</code> and <code>resize</code> events. lodash and underscore both offer well-tested and robust throttle and debounce functions which can simply wrap other functions. However, I wanted to use requestAnimationFrame, and I came up with a handy little ditty to enable a similarly easy means to wrap functions for a kind of auto-throttle.</p>

<pre><code>function rebounce( fn ){
  var timeout, args, context;
  return function (){
    context = this;
    args = [].slice.call( arguments, 0 );
    cancelAnimationFrame( timeout );
    timeout = requestAnimationFrame( function (){
      fn.apply( context, args );
      timeout = null;
    });
  }
}
</code></pre>

<p>which then enables you to apply your scroll handler in this very simple way:</p>

<pre><code>window.addEventListener( "load",   lazyload, false );
window.addEventListener( "scroll", rebounce( lazyload ), false );
window.addEventListener( "resize", rebounce( lazyload ), false );
</code></pre>

<p>Nota bene: lazy-load initially on <code>DOMContentLoaded</code> or <code>load</code>/<code>onload</code>, because you&rsquo;ll presumably have removed all of your <code>src</code> attributes from your markup, leaving blank space without triggering the first lazy-load as soon as the document is ready.</p>

<p>Final tip: obviously removing all of your <code>src</code> attributes and whatnot will cause an issue for users who do not have JavaScript enabled. To solve this problem, include all of your images in the normal way but wrapped in <code>noscript</code> elements, like ghostly twins to your lazy-loaded elements.</p>

<p>You can see <a href="https://toad.js.org">my lazy-loading implementation in action here</a> &middot; <a href="https://github.com/wnda/toad">Full source</a> on Github.</p>]]></content:encoded></item><item><title><![CDATA[Why the new fetch API is broken]]></title><description><![CDATA[<p>There is probably no DOM API more loathed than the <code>XMLHttpRequest</code>, but is the hatred really justified? It probably was when web browsers did not implement it consistently, but these days you can pretty much get by with the same code in every browser. A <code>GET</code> request might look something</p>]]></description><link>https://amdouglas.com/why-the-new-fetch-api-is-broken/</link><guid isPermaLink="false">39375b36-5cdd-45f6-a2a9-5cf8904a8ae3</guid><category><![CDATA[javascript]]></category><category><![CDATA[ajax]]></category><dc:creator><![CDATA[A. M. Douglas]]></dc:creator><pubDate>Fri, 19 Aug 2016 18:59:00 GMT</pubDate><content:encoded><![CDATA[<p>There is probably no DOM API more loathed than the <code>XMLHttpRequest</code>, but is the hatred really justified? It probably was when web browsers did not implement it consistently, but these days you can pretty much get by with the same code in every browser. A <code>GET</code> request might look something like this:</p>

<pre><code>var xhr = new XMLHttpRequest();

xhr.open( 'GET', url );

xhr.onreadystatechange = function(){
  if ( this.readyState === )
  {
    if ( 4 &amp;&amp; this.status &gt;= 200 &amp;&amp; this.status &lt; 300 )
    {
      // do stuff;
    }
  }
};

xhr.onabort = xhr.onerror = function(){
  console.info( 'There was an error with the request' );
};

xhr.send();
</code></pre>

<p>That will more or less work anywhere. And it's not particularly horrific to look at. It's certainly not pretty, but it used to be much worse in the ActiveX days.</p>

<h3 id="enterfetch">Enter fetch</h3>

<p>Now there's a new kid in town—<a href="https://fetch.spec.whatwg.org/">the fetch API</a>—and, looking at that spec, web developers around the world should be rejoicing. Finally, something that looks like jQuery but in vanilla JavaScript, thank goodness!</p>

<p>But we're not rejoicing. At least, I'm not, and I've noted a number of others not particularly happy with the new kid. Despite many articles hailing it as the future, and others <a href="https://developers.google.com/web/updates/2015/03/introduction-to-fetch?hl=en">waving XHR goodbye</a> The first and foremost complaint is the fact that it is Promise-based, <a href="https://github.com/whatwg/fetch/issues/20">and thus does not presently offer any means of aborting a request</a>. This issue is plain to see, and will probably be fixed (one day).</p>

<p>I take issue with something just as fundamental: it leads to ugly code and offers less power than XHR2.</p>

<h3 id="thecaseagainstfetch">The case against fetch</h3>

<p>Let's look at that XHR code again. If I wanted to use that snippet to get another page of my website and load it into the current document, replacing the old page and effectively loading the new page without a full browser refresh, I could obviously parse the response using the HTML parser built into the vanilla DOM, but this wouldn't be necessary thanks to the XHR2 spec, which includes the ability to set a response type. Thus, in order to get a document which can be <code>querySelector</code>'d and so on, all we have to add is this:</p>

<pre><code>xhr.responseType = 'document';
</code></pre>

<p>Very, very simple.</p>

<p>Fast-forward to the fetch API. The same code looks like this:</p>

<pre><code>fetch( url, {
    method: 'GET',
    headers: { 'Content-Type' : 'text/html' },
    mode: 'same-origin'
}).then( function( response ){

    var contentType = response.headers.get( 'Content-Type' );

    if ( response.ok &amp;&amp; contentType &amp;&amp; contentType.indexOf( 'text/html' ) !== -1 ){
      return response.text().then( function( resptxt ){

        var parser = new DOMParser(),
            doc = parser.parseFromString( resptxt, 'text/html' );

        // do something with the new document

      }).catch( function(){ console.info( 'Error: No HTML received' ) });
    }
  }).catch( function( response ){ console.info( 'Error: ' + ( response.message || 'No data available' ) ) });
</code></pre>

<p>Your eyes do not deceive you: the fetch API actually leads to more verbose code. Here I have to manually set a content type checker, resolve the text from the response Promise and parse the text with the DOM API! It's absurd!</p>

<h3 id="whyfetchthen">Why fetch then?</h3>

<p>Ultimately, this is because the fetch API, despite having poor browser support, is actually more low-level than XHR. XHR is to be defined in fetch in the end, and such things as <code>xhr.responseType = 'document'</code> will probably be defined in much the same way as I have outlined.</p>

<p>This does of course invite the question of when to actually use fetch. The use cases become clear when you consider streaming (fetch responses are Stream objects, and are thus asynchronous by nature) and Service Workers.</p>

<p>Like many low-level APIs, you should stick to using XHR2 unless there's something you specifically need from the fetch API like streams.</p>]]></content:encoded></item><item><title><![CDATA[Formalhaut.js]]></title><description><![CDATA[<p>Formalhaut.js is a vanilla (i.e. not jQuery) JavaScript library which looks for HTML forms in the DOM and automatically handles the submit event via AJAX. </p>

<p>The name is a deliberate and corny perversion of Fomalhaut, which is the brightest star in the Pisces constellation. So, quite naturally, it</p>]]></description><link>https://amdouglas.com/formalhaut-js/</link><guid isPermaLink="false">a7548bc6-1e0f-4807-8f43-24a2aef9cf6d</guid><category><![CDATA[javascript]]></category><category><![CDATA[html]]></category><dc:creator><![CDATA[A. M. Douglas]]></dc:creator><pubDate>Sun, 14 Aug 2016 22:41:00 GMT</pubDate><content:encoded><![CDATA[<p>Formalhaut.js is a vanilla (i.e. not jQuery) JavaScript library which looks for HTML forms in the DOM and automatically handles the submit event via AJAX. </p>

<p>The name is a deliberate and corny perversion of Fomalhaut, which is the brightest star in the Pisces constellation. So, quite naturally, it has absolutely nothing to do with forms, it's just a word I'm familiar with which could be adapted to include the word &lsquo;form&rsquo;.</p>

<p>Formalhaut started life as a pair of enormous functions to handle an XMLHttpRequest submission of a form, which originally included validation logic. It worked nicely but some parts were, for all intents and purposes, hard-coded.</p>

<p>It wasn't until I came to repeat the process of writing logic to submit a form by AJAX without jQuery, or any other abstraction library, that I felt a need to develop something I could reuse. This was not because I didn't value the idea, but rather because my schedule was too busy and much of my work at that time consisted of rewriting or finishing messy/broken/slow websites written by others, where too much already depended on jQuery for it to be removed (and thus I was able to just do <code>$.ajax</code> without a care in the world.</p>

<p>I've always preferred writing vanilla JavaScript, however. I grew up messing with Perl and &lsquo;DHTML&rsquo; and so when syntactic sugar libraries came along, they merely represented time-sinks for some gains to developer-friendliness (which, being a freelancer, I didn't need, and being me, didn't want) and for losses w.r.t. performance. jQuery was of course very helpful in fast-moving projects where browser-compatibility was not a straightforward problem to solve, but that, for me, is its only use.</p>

<p>jQuery's simplicity has naturally given rise to a huge and scattered eco-system of &lsquo;plugins&rsquo;, many of which make sophisticated animations and complex web application UIs almost trivial to build. It wasn't jQuery that ushered in the age of the single-page application—I'm sure you can remember those awful Adobe Flash websites where you couldn't copy and paste anything and links couldn't be opened in new tabs, and so on).</p>

<p>However, if the JavaScript community as a whole gained something from jQuery, besides a good lesson in how to design a complex library, the community must surely have seen the value of having reusable plugins that could effectively componentise web development. Sure enough, the two JavaScript frameworks/libraries on everybody's lips these days are React and Polymer—both of which are designed to enable developers to build composable, reusable snap-ins, enabling websites which can be put together almost automatically.</p>

<p>While I dislike both React and Polymer for a number of reasons,* the fundamental idea of reusing solid libraries enables developers to move faster. To that end, I've been writing JavaScript libraries whenever I have been unable to find one that did what I wanted it to do, or whenever the ones available were: </p>

<ul>
<li>over-engineered</li>
<li>slow</li>
<li>huge</li>
<li>obtuse</li>
<li>broken</li>
<li>all of the above</li>
</ul>

<p>So far, I've written libs to animate DOM elements in three dimensions responding to the pointer; to display an EU-required cookie warning; to lazyload images and CSS background-images based on viewport visibility; and to trivialise the creation of tabs/tabbed sections of content. Now, to that list, I append my form auto-AJAXifier.</p>

<p>Unlike my other libraries, formalhaut requires no configuration (at the moment). This is largely because the library checks the DOM for forms and configures itself based on attributes specified on the form. This made sense initially, because the <code>content-type</code>, <code>accept-charset</code>, <code>HTTP method</code>, and the URL being targeted, are all specifiable using the valid HTML attributes: <code>enctype=""</code>, <code>accept-charset=""</code>, <code>method=""</code>, and <code>action=""</code> respectively.</p>

<p>Formalhaut currently works as a blunt, everything-or-nothing drop-in. Include it at the bottom of the <code>body</code>, make sure your forms have the right attributes and you're done. Your form submissions will be interrupted and sent via fetch/XHR instead.</p>

<p>The beauty of the library is that, by using attributes like <code>method</code> and <code>enctype</code>, we can gracefully degrade to native form submit behaviour if the user doesn't have JavaScript switched on, so a bit of work on your router will enable both AJAX and native form submission handling.</p>

<p>So how does it work? Let's have a look at the library's anatomy. The library is exposed as a global object which, when the <code>init()</code> is called, finds all of the forms for a given <code>document</code> and adds the formalhaut submit event handler.</p>

<pre><code>e.preventDefault();
var form   = ( e.target || this );
var query  =
  (function(){
    var inputs = form.querySelectorAll( settings.selector ),
        i      = inputs.length,
        j      = 0,
        str    = [];

    for( ; i &gt; j; j++ ){
      var q = (
        !!inputs[j].getAttribute( 'name' ) &amp;&amp; !!inputs[j].value ?
        inputs[j].getAttribute( 'name' ) + '=' + inputs[j].value :
        !1
      );

      !!q &amp;&amp; str.push( q );
    }

    if( !str.length ){
      console.error( 'Error in constructing query: no named input' );
      return false;
    }
    else {
      return str.join( '&amp;' );
    }
  }());

!!query &amp;&amp; formalhaut.sendForm( query, form );
</code></pre>

<p>This code would be considered terse by most JS developers used to plastic-packed frameworks with easy-open, &ldquo;tear here&rdquo; APIs, but that&rsquo;s not what I aim to create. My snippets/libraries are not intended to replace a framework in any big web app; they're designed to be drop-ins for static sites and generic marketing sites where a minimum of dynamic functionality is desirable.</p>

<p>It's very crude but it saves plenty of time if you're just working on simple sites for local businesses (as I often do because I prefer freelancing over working for some big corporation's advertising/content-marketing machine) and you want to achieve a nice and simple user experience without including jQuery just for <code>$.ajax</code>.</p>

<p>My plan to improve the library will involve adding the ability to ignore form attributes and to supply configuration objects instead. Forms themselves will not be grabbed as one NodeList/HTMLCollection using <code>document.forms</code> (though this will be the default behaviour) and instead it will be possible to initialise multiple instances of formalhaut to target different forms, or groups of forms, based on CSS selectors.</p>

<p>You can see the library in action here: <br>
<a href="https://formalhaut.js.org">https://formalhaut.js.org</a></p>

<p>and you can view the source code here: <br>
<a href="https://github.com/wnda/formalhaut">https://github.com/wnda/formalhaut</a></p>]]></content:encoded></item><item><title><![CDATA[AMP: full circle]]></title><description><![CDATA[<p>A few months ago I declared that AMP-HTML was of little use to a blog, especially one has finely-tuned for performance as mine, which serves nothing but text and <code>woff2</code> fonts. </p>

<p>And yet, up until a few days ago, if you were to open your web inspector tools you would</p>]]></description><link>https://amdouglas.com/amp-full-circle/</link><guid isPermaLink="false">a2ba0a34-b5f7-498d-84d2-fb73df2372b6</guid><category><![CDATA[javascript]]></category><category><![CDATA[amphtml]]></category><dc:creator><![CDATA[A. M. Douglas]]></dc:creator><pubDate>Fri, 12 Aug 2016 20:23:00 GMT</pubDate><content:encoded><![CDATA[<p>A few months ago I declared that AMP-HTML was of little use to a blog, especially one has finely-tuned for performance as mine, which serves nothing but text and <code>woff2</code> fonts. </p>

<p>And yet, up until a few days ago, if you were to open your web inspector tools you would have seen that this was a valid AMP-HTML page. Why did I implement it anyway?</p>

<p>My primary motivation for implementing AMP-HTML on my own site was to learn the ins and outs of the system. What I discovered was that, while very easy to integrate into existing systems, the benefits are somewhat negligible for anybody publishing content on a less than real-time basis.</p>

<p>What do I mean by this? Well, AMP has one selling point for businesses: a place in the AMP carousel on mobile, literally the top spot, along with instant content delivery from the AMP CDN. Very nice. The problem is that your business probably doesn't generate daily news articles like The Guardian or The Washington Post does, so your content is unlikely to qualify for the AMP carousel.</p>

<p>Blog articles certainly don't, as I discovered through experience, and while this might be expanded in the future, I was generally finding the experience a little futile. For starters, my pages were blank on my iPhone 5 running iOS10β5. While this is to be expected with a developing library/framework, it still annoyed me and made me fear for a website's theoretical readership (probably 2 people in my case) who would be unable to see content or navigate further.</p>

<p>Analytics is also far from a state of readiness, and while some interesting things are in the pipeline like <code>amp-list</code>, a custom element for fetching related content from a REST API, I just couldn't see a benefit to persevering with the AMP framework.</p>

<p>So, once again, I've decided to go it alone without AMP. Another motivating factor behind this decision was my recent composition of the <code>pfetch</code> JavaScript library and my desire to expand and use it on my site in place of <code>pjax</code>, which is obviously not really applicable in the case of a site using AMP. AJAXing content around improves perceived performance more than a potentially blank screen and bragging rights about a thunderbolt emoji in my root element ever will.</p>]]></content:encoded></item><item><title><![CDATA[CSS selectors you really may not have heard of]]></title><description><![CDATA[<p><a href="https://medium.com/@adamemdouglas/advanced-css-selectors-you-really-may-not-have-heard-of-and-if-you-have-you-probably-haven-t-a888515e8f2#.bdq0rq43p">This article was first published by me on Medium</a> as an unsolicited continuation of <a href="https://medium.com/the-web-crunch-publication/advanced-css-selectors-you-never-knew-about-972d8275d079#.ud5edb8qo">this article</a> purporting to document a number of “advanced CSS selectors” which the reader “has never heard of”.</p>

<p>While attribute/partial selectors can be considered quite “advanced”, the author forgot to mention something important: that they</p>]]></description><link>https://amdouglas.com/real-advanced-css-selectors-you-may-have-heard-of/</link><guid isPermaLink="false">61a3ba56-c8ab-4e94-b151-7c13003e44ef</guid><dc:creator><![CDATA[A. M. Douglas]]></dc:creator><pubDate>Sat, 12 Mar 2016 20:05:19 GMT</pubDate><content:encoded><![CDATA[<p><a href="https://medium.com/@adamemdouglas/advanced-css-selectors-you-really-may-not-have-heard-of-and-if-you-have-you-probably-haven-t-a888515e8f2#.bdq0rq43p">This article was first published by me on Medium</a> as an unsolicited continuation of <a href="https://medium.com/the-web-crunch-publication/advanced-css-selectors-you-never-knew-about-972d8275d079#.ud5edb8qo">this article</a> purporting to document a number of “advanced CSS selectors” which the reader “has never heard of”.</p>

<p>While attribute/partial selectors can be considered quite “advanced”, the author forgot to mention something important: that they are supported even as far back as Internet Explorer 7. It’s not really fair to say that no-one has heard of these in particular, since they’ve been around for so long, are used by so many people and projects. </p>

<p>The primary reason for their apparent obscurity today is the fact that, compared to selecting by class, tag or id, it’s rather inefficient. Nevertheless, some column-based grid systems still use them.</p>

<p>The other selectors mentioned are, in my opinion, quite well-known albeit largely useless.</p>

<p><code>:not(x)</code> has been discussed on the net for a long time, but it’s really only useful for distinguishing between <code>:hover</code>, <code>:active</code> and <code>:focus</code> states on input fields. Ultimately <code>:not(x)</code> promotes the writing of bad CSS, because you should use specificity and inheritance, rather than negation.</p>

<p>Similarly, <code>:first-of-type</code> and <code>:last-of-type</code> are also not really indicative of well-planned CSS. It would be useful if it would select the first instance of an element within all parent elements, but it rather works like <code>element.querySelector</code> in JavaScript: it selects only the first instance of a selector globally. </p>

<p>If you need to target something so specifically and not in multiple cases, you should probably just give it specific CSS class or an id. If you intend to select the first element in multiple instances — say, in a row when using a grid system — use <code>:first-child</code> and <code>:last-child</code>.</p>

<h3 id="somereallyunderusedcsspseudoselectors">Some really underused CSS pseudo-selectors</h3>

<p>You might disagree with my statements about those selectors above, maybe you find them super useful; I personally rarely (if ever) use <code>:not(x)</code>, <code>:first-of-type</code>, <code>:last-of-type</code>, et cetera. I think these are some more exciting pseudo-selectors that deserve some attention.</p>

<h4 id="validinvalid"><code>:valid</code> &amp; <code>:invalid</code></h4>

<p>The aforementioned article includes a careless list of extremely well-known pseudo-selectors like <code>:hover</code>, <code>:active</code>, <code>:focus</code> and <code>:visited</code> — while JavaScript is still used by some to handle basic hover effects (yes, even in 2016), these pseudo-selectors are more or less common knowledge. Even <code>:checked</code> sees some usage, especially in Codepens, or in production when native checkbox/radio inputs are replaced with custom graphics.</p>

<p>Something that seems more obscure in the wild are the <code>:valid</code> &amp; <code>:invalid</code> selectors. Their obscurity probably stems from the fact that there’s not much point delegating responsibility for form validation feedback to CSS. JavaScript will almost always be relied upon to detect invalid form entries in a production-ready site anyway, and it seems only natural to let JavaScript act upon invalid entries and indicate state while you’re at it. </p>

<p>This might seem unnecessary to those of you who know the power of HTML5’s new attributes for input fields, like the introduction of the pattern attribute — but not everybody uses a browser which supports HTML5 pattern matching on input fields, and form validation is definitely one of those things that cannot be considered a progressive enhancement. It should be a core feature supported for all.</p>

<p>Of course, JavaScript itself should be a core feature, yet it is possible for users to switch it off. What should one do in those cases when you still want to communicate state to your users? Well, in an ideal world where everybody uses a modern web browser, <code>:valid</code>/<code>:invalid</code> make it very easy to provide feedback on forms without adding/removing classes programmatically. You can use <code>:valid</code>/<code>:invalid</code> in combination with required and pattern attributes, can remove the requirement for JavaScript for form validation.</p>

<h4 id="target">:target</h4>

<p>There’s only really one advanced pseudo-selector that is barely known even among veterans of web development — the <code>:target</code> pseudo-selector. It has creeped into the occasional example, but it’s largely unheard of. </p>

<p>This is probably because it seems largely useless: the first hit on Google involves an article split into hash-linked sections. When the user navigates to a hash-link, <code>:target</code> is then used to apply some indicative styles to the section that the reader has jumped, for the sake of increased user-friendliness. (This example can be found here.)</p>

<p>Yet <code>:target</code> is in fact far more powerful than all that. You can mimic the functionality of a lightbox by using the <code>:target</code> selector. To do this, you might start with some basic code like this:</p>

<p>CSS:</p>

<pre><code>*,:before,:after
{
  box-sizing:       border-box;
  margin:           0;
  padding:          0;
  border:           0
}

nav
{
  display:          table;
  position:         fixed;
  top:              0;
  left:             0;
  right:            0;
  z-index:          100;
  width:            100%;
}

nav &gt; a
{
  display:          table-cell;
  font-size:        21px;
  line-height:      1.5;
  text-decoration:  none;
  background-color: white;
  color:            crimson;
}

img
{
  display:          none
}

:target img
{
  display:          block;
  position:         fixed;
  top:              50%;
  left:             50%;
  transform:        translate(-50%, -50%);
  width:            100%;
  max-width:        400px;
  height:           auto;
  z-index:          2;
}

:target:after
{
  content:          '';
  display:          block;
  position:         fixed;
  top:              0;
  left:             0;
  bottom:           0;
  right:            0;
  width:            100%;
  height:           100%;
  z-index:          1;
  background-color: hsla(0, 0%, 0%, 0.6);
}
</code></pre>

<p>HTML:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;nav&gt;
  &lt;a href="#i"&gt;Figure I&lt;/a&gt;
  &lt;a href="#ii"&gt;Figure II&lt;/a&gt;
&lt;/nav&gt;

&lt;figure id="i"&gt;
  &lt;img src="http://i.imgur.com/anS0VlU.jpg"&gt;
&lt;/figure&gt;

&lt;figure id="ii"&gt;
  &lt;img src="http://i.imgur.com/aKN6vdJ.jpg"&gt;
&lt;/figure&gt;

&lt;/html&gt;
</code></pre>

<p><a href="https://mdn.mozillademos.org/files/4607/lightbox.html">A better example can be found here, courtesy of MDN.</a></p>

<p>You can build tabs or even carousels with the same principles. Here is an example of a no-JavaScript-required carousel I made earlier.</p>

<h3 id="epilogue">Epilogue</h3>

<p>These pseudo-selectors are largely useless given the complexity of real-world apps and the fact that JavaScript enables all of this functionality to be governed from one place. Delegating some things to CSS and others to JavaScript produces less maintainable code. </p>

<p>However, if you’ve just got a random project on the table, or even if you want to build a slideshow and you were considering something like <strong>impress.js</strong> or <strong>reveal.js</strong>, I’d give <code>:target</code> some consideration. </p>

<p>If you’ve got a trivial form on your website, or if you’d like a fallback method for showing validation states on your input fields, consider <code>:valid</code>/<code>:invalid</code>. Your actual validation should be carried out server-side anyway, because client-side validation can and will be circumvented, no matter if its JavaScript or native HTML5.</p>]]></content:encoded></item><item><title><![CDATA[Some CSS pointers]]></title><description><![CDATA[<p>If you're a regular reader of articles in web development, you've probably seen a lot of literature being generated about the topic of developing client-side, single page applications using React.js (and all the baggage it more or less requires to be a good idea) and the shift away from</p>]]></description><link>https://amdouglas.com/useful-css-tricks/</link><guid isPermaLink="false">dda0ccbc-41ab-444b-a728-18a8dae2456e</guid><category><![CDATA[css]]></category><category><![CDATA[layout]]></category><dc:creator><![CDATA[A. M. Douglas]]></dc:creator><pubDate>Thu, 28 Jan 2016 00:19:42 GMT</pubDate><content:encoded><![CDATA[<p>If you're a regular reader of articles in web development, you've probably seen a lot of literature being generated about the topic of developing client-side, single page applications using React.js (and all the baggage it more or less requires to be a good idea) and the shift away from CSS and toward attribute styles in JSX, in order to create discrete components.</p>

<p>This is not one of those articles. Nope, this is just a humble list of CSS gotchas that can result in noticeably poor perceived performance on your website&mdash;even if you don't use any JavaScript at all, complex and poorly planned visual effects composed with CSS3 transitions, animations and properties can cause a very real drop in framerate, which is ultimately the same complaint many users have with heavy JavaScript applications. Client-side apps use significant abstractions on vanilla JavaScript objects/methods in order to make the developer's life easier and to make a more fully rounded product&mdash;at the expense of operations per second and thence, perceived frames per second.</p>

<h3 id="dontusebackgroundattachmentfixed">Don't use 'background-attachment: fixed'</h3>

<p>I've seen <code>background-attachment: fixed</code> many times, usually where a web developer wanted to create a pseudo-parallax scrolling effect with no JavaScript involvement, due to the performance issues involved with true parallax scrolling, only to drop frames due to this ill-advised approach to CSS.</p>

<p>The problem is that <code>background-attachment: fixed</code> causes the browser to repaint on every scroll, which is damned expensive. You can watch your silky 60fps slashed by 75% even on a laptop because there is no simple way to get the GPU involved in processing this more complex visual effect.</p>

<p>Its use is not the crime, however. It's a nice effect and effortlessly nice to look at in many cases. The crime is not using the hardware-accelerated and simple alternative: <code>position: fixed</code>. Or, to put it more comprehensively:</p>

<pre><code>.parallax-bg
  {
    position:fixed;
    top:0;
    left:0;
    right:0;
    bottom:0;
    will-change:transform;
    z-index:-1
  }
</code></pre>

<p>That's pretty much it. <code>will-change</code> creates a new compositing layer and gets the GPU to step up a gear, giving you silky smooth performance again. <code>will-change</code> is a standard property and not specific to any browser, but obviously that does not mean that it is implemented everywhere yet. </p>

<p>For those cases, like Safari (<a href="http://caniuse.com/#feat=will-change">excluding 9.1 and above</a>) and obviously IE, the GPU can be levied by adding <code>transform: translateZ(0)</code> which is a well known workaround, but this old approach presents a risk to performance if abused, especially on mobile devices which have less memory to play with. Scrolling past these elements can be smooth, but the elements themselves might look a little rough&mdash;it has been recommended to add <code>backface-visibility: hidden</code> and <code>perspective: 1000</code> to try to mitigate this. On the whole, though, the old method does precisely the same thing as <code>will-change</code>&mdash;translates an element in dimension Z by 0&#119899; where 𝓷 is some unit like <code>px</code> or <code>%</code>, thereby preparing the element for GPU accelerated movement. Obviously some details will be specific to your use case: you may wish to define a height as a percentage of the viewport with <code>vh</code> and so on.</p>

<h4 id="responsivesquares">Responsive squares</h4>

<p>Yes, it's funny, but creating things that are <strong>perfectly</strong> square in all viewports can seem challenging at first. You can imagine the problem: you want to display a grid of items&mdash;perhaps photographs&mdash;and, upon being floated, those elements lose their height.</p>

<p>Now, sure, if you supply square images, it's not a problem&mdash;<code>max-width:100%;height:auto</code> and you're more or less done; but what if you're making a real website, for real people, who do not have a process for photographic content on the web, who do not have you or your grid's ergonomics in mind.</p>

<p>Obviously, you'd use <code>background-image</code> and <code>background-size:cover</code>. That solves the responsive image issue&mdash;now any image will fit your containing element. Except now your photo has no height again, and it'd be understandably quite difficult to construct a square without a value for &#119910;. Sure, floated elements can at least be assigned a <code>min-height</code> to prevent this, but you'll end up with inconsistent heights&mdash; and we all know what happens in a traditional float-based grid when you just throw elements of different heights together (I discuss this in my previous post <a href="https://amdouglas.com/you-might-not-need-masonry">You Might Not Need Masonry</a>).</p>

<p>One way some misguided developers try to achieve height equivalence is to use a min-height or height that is all but guaranteed to exceed the content the element will contain. This can be seen in many implementations of &ldquo;card&rdquo; design patterns, though the flexible box model offers a more reliable approach. But sometimes, you really need to display a square.</p>

<p>The correct (and by correct, I mean reliable) way to achieve this is to float your grid items and add a child element with a total vertical padding of 100% and no height or content. <a href="https://amdouglas.uk/css-examples/squares/">You can see this CSS technique demonstrated here</a>.</p>

<p>Users of this technique, or more complex variants of it, include <a href="https://www.instagram.com">Instagram</a> and the <a href="http://www.bbc.co.uk/radio1/playlist">BBC</a>.</p>

<h3 id="dontuseinlineblock">Don't use inline-block</h3>

<p>There is no justification for using inline-block. It's quite possibly the most useless thing in your CSS toolkit that you could ever be tempted to use. There was once an argument for its use over <code>float</code> in grid systems, if you were willing to <a href="https://css-tricks.com/fighting-the-space-between-inline-block-elements/">hack your way around</a> the <a href="http://robertnyman.com/2010/02/24/css-display-inline-block-why-it-rocks-and-why-it-sucks/">white space problem</a>, because inline-block elements behave like <code>flex-flow:row wrap</code> with better browser support.</p>

<p>However, setting your font-size to zero, eliminating white space in one particular part of your HTML, or not closing your HTML tags, are not exemplary practices in terms of maintaining clean code. After temporarily daring to use flexbox in a couple of small projects, I have concluded that the United Kingdom is not ready for it, and so I continue to use <code>float</code> based grid systems for my work, though I at least include <code>calc</code> with a percentage fallback for my own satisfaction. And float works very nicely for the most part, but there's one troublesome region of the typical web page where float sometimes doesn't cut it: the navigation bar.</p>

<h3 id="centeringwithoutflexbox">Centering without flexbox</h3>

<p>Navigation bars are pretty straightforward for your average website, but sometimes you get fed a design which just happens to stick a logo or main menu smack bang in the middle of said navigation bar. But you don't need to fear, you're a worldly front-ender, it's easy. Just use <code>margin:0 auto</code> and you'll be fine.</p>

<p>Oh dear. It looks like the design calls for social media icons on the left, and something else even dafter on the right. So you can either <code>float</code> those left and right respectively and then center the logo&mdash;or you could just use your grid system for a trio of columns in the navigation bar. Which will work great, except perhaps you want to vertically align these things as well. Not out of the woods yet. Some might say that you should use the following method:</p>

<pre><code>.navbar
  {
    position:relative
  }

.valigned
  {
    position:absolute;
    top:50%;
    transform:translateY(-50%)
  }
</code></pre>

<p>Sure, it'll work, but I recommend caution, especially if you need to support IE8.</p>

<p>If you need to support antiquated browsers, you should use <code>display:table</code> and <code>display:table-cell</code> which gives you the vertical alignment powers of those <code>&lt;table&gt;</code> elements that most of us don't have to think about much any more (as an email coder as well as a web developer, I unfortunately have to deal with table elements every week&mdash;I do not think it is an activity for people who happen to possess souls).</p>

<p>You might be wondering how the hell you can make a table-navbar responsive. It's very simple actually: let your elements start as block elements floated left and then above a minimum width adjust their display property to table/table-cell.</p>

<h3 id="backgroundurlvideowebm50cover">background: url(video.webm) 50% / cover;</h3>

<p>Nope, I'm sorry, this is not something newly implemented and I do not today have the pleasure of unveiling this amazing leap forward in CSS. But I can show you how to achieve the same effect:</p>

<pre><code>.bg-video
  {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%,-50%);
    min-width: 100%;
    min-height: 100%;
    width: auto;
    height: auto;
    z-index: -1
  }
</code></pre>

<p>You can see this <a href="https://amdouglas.com/404/">CSS in action on my 404 page</a>.</p>]]></content:encoded></item><item><title><![CDATA[Constructing a Grid System with Flexbox]]></title><description><![CDATA[<p>If you want to skip the commentary, <strong><a href="https://wnda.github.io/morag/" title="Live demo of the Morag CSS Grid">check out the demo</a></strong> or <strong><a href="https://github.com/wnda/morag" title="wnda on GitHub: Morag CSS Grid">dive into the source code</a></strong>.</p>

<p>It's 2015 now, soon to be 2016; there's no shortage of methods by which block-level elements can be arranged in a grid formation, in order to take advantage of a desktop computer's screen</p>]]></description><link>https://amdouglas.com/constructing-a-css-grid-system-with-flexbox/</link><guid isPermaLink="false">40f2174c-09aa-4777-9856-ee95034a62f2</guid><category><![CDATA[css]]></category><category><![CDATA[flexbox]]></category><dc:creator><![CDATA[A. M. Douglas]]></dc:creator><pubDate>Mon, 25 Jan 2016 01:07:39 GMT</pubDate><content:encoded><![CDATA[<p>If you want to skip the commentary, <strong><a href="https://wnda.github.io/morag/" title="Live demo of the Morag CSS Grid">check out the demo</a></strong> or <strong><a href="https://github.com/wnda/morag" title="wnda on GitHub: Morag CSS Grid">dive into the source code</a></strong>.</p>

<p>It's 2015 now, soon to be 2016; there's no shortage of methods by which block-level elements can be arranged in a grid formation, in order to take advantage of a desktop computer's screen real estate. However, most of these grid systems are all fundamentally flawed for well documented reasons.</p>

<p>So, rather than delve into the flaws inherent in traditional grid systems for what would be the millionth time, I'd like to create a new grid system using <code>flexbox</code> and <code>calc</code> to avoid the historically unavoidable pitfalls.</p>

<h3 id="modernbrowsertech">Modern browser tech</h3>

<p>Yes, this will be a <code>flexbox</code> grid. If you need to support IE6 as anything more than an afterthought, you should probably stick with whatever you're using. My solution offers a modern approach to grids as a progressive enhancement from a float-based grid. </p>

<p>Be warned: it requires <code>box-sizing</code> and pseudo-elements (<code>::before</code>,<code>::after</code>). Obviously, <code>box-sizing</code> can be polyfilled and pseudo-elements either swapped out for clearfix <code>div</code> but seriously, unless you're really looking to have a slightly improved look for your modern users, don't read on.</p>

<p>If you're still with me, I can only presume that you care about serving content in an orderly fashion to the 80% of the internet that is&mdash;to sound like a television salesman&mdash;<code>flex</code>-ready.</p>

<h3 id="acolumnbyanyothername">A column by any other name...</h3>

<p>I'm not kidding. If you're a designer, you might now know the serious problem that some developers experience when it comes to naming. I'm not among them, but that's only because of a necessary apathy. If I cared that everything had the perfect name, I'd die before I finished any project, because there is no such thing as an objectively perfect anything&mdash;let alone an objectively perfect name.</p>

<p>For my grid, I went with grids and cells. This is because, in order for my grid to be worthy of existence at all, it would need to actually solve the historical problem with float-based grids which is that you cannot exceed 12 cells in a grid, which is why in those grid systems, the clearing containers would be called rows and the cells would be called columns.</p>

<p>My grid system <strong>actually</strong> represents a grid.</p>

<h3 id="takingoffisthehardestpart">Taking off is the hardest part</h3>

<p>Surprisingly, it has never been the construction of the actual row/column layout in pure CSS that has been the problem. It has always been the gutters, or spacing between the columns, that have proven tricky for developers to nail down. </p>

<p>The whole point of a grid system is to have something that can be used over and over again, for any layout task; the thing that makes it difficult for a grid system to be used for any task is the fact that the means by which cell-spacing is achieved is typically suitable only in <strong>some</strong> cases, while inappropriate or downright offensive in others.</p>

<p>Using <code>display: inline-block</code> for your CSS grid items sort of provides you with cell-spacing automatically, but of the worst possible kind. The kind that can't be removed by CSS, only by HTML minification (unreliable) or DOM manipulation (absurd).</p>

<p>I wanted to be able to use <code>margin</code> rather than <code>padding</code>, because the latter leaves no means of alternating background color while maintaining color-agnostic gutters. This had previously been impractical to implement, as the implementations would involve either:</p>

<ul>
<li><code>margin</code> defined as a percentage (e.g. <code>margin: 0 3% 3%</code>)</li>
<li><code>margin</code> values altered by <code>:nth-child</code> selector (or worse, JavaScript)</li>
</ul>

<p>Neither of these approaches are worth the hassle and most decent grid systems would stick to adding <code>padding</code> to the grid cell and then adding a div within the cell. It works reliably, but it means another node in the DOM tree and I like to think that layout shouldn't be controlled by adding more nodes, or else markup is defining layout/style and you may as well have stuck with tables.</p>

<p>The way to beat this is to use margin with the marvel of <code>calc</code>. <code>calc</code> is not at all new to CSS, and not even new to grid systems. Obviously, expressing a rational number width like 1/3 is much more precise with <code>calc</code>—compare <code>33.333%</code> with <code>calc(100% / 3)</code>—and with this precise calculation, unexpected behaviour is less likely to occur in browsers which support it.</p>

<p>However, perhaps <code>calc</code> can be used to do even more for a grid system here. Imagine: now we can set the width of a grid cell to be a fraction minus a value of our choosing—like, say, a value equal to a margin we might pick for our grid cells!</p>

<p>What was once:</p>

<p><code>.cell-lg-3 { width:33.3333% }</code></p>

<p>can now become:</p>

<p><code>.cell-lg-3 { width:calc(100 / 3 - 16px) }</code></p>

<p>However, the million dollar question then is this: how does one nest grids with cell-spacing? For this, I turned to Bootstrap, which had long handled the problem of nested grids rather well in my opinion.</p>

<h3 id="bootflex">Bootflex</h3>

<p>Bootstrap is widely regarded as one of the most successful grids on the internet. Very fancy grids have been developed using LESS, SASS, Stylus and god knows what else, but still many developers just grab the Bootstrap grid because it just works.</p>

<p>Bootstrap's method for enabling the nesting of grids is simple: apply a negative margin on the grid row. This enables the cells to behave as though they possessed no gutters relative to the row, while retaining the gutters between each other.</p>

<p>This approach did carry a slight snag for me, however: centering content without being able to declare <code>margin: 0 auto</code> is a little challenging. This would have been perfectly acceptable with <code>width: 100%</code>, but adding a <code>margin</code> on grid cells and subtracting the difference from the width initially left an annoying asymmetrical gap on the top-level containing grid. </p>

<p>Fortunately, <code>flex</code> once again offers the solution. By making your grid rows <code>flex-direction:row</code> and your grid cells <code>flex-direction:column</code> you automatically make it possible to nest and center grids using <code>align-items</code> or <code>align-self</code> (depending on your cirumstances).</p>

<h3 id="theremedyisworsethanthedisease">The remedy is worse than the disease</h3>

<p>In order to achieve equivalent heights between parallel grid cells, I was using <code>align-items: stretch</code> on cells. An interesting and unanticipated caveat with <code>align-items: stretch</code> is that it actually aligns the cell to the left while stretching it, leaving no gap to the left and a double gap to the right. Setting <code>margin: 0 auto</code> and a width/max-width on the containing element would normally have fixed this, but the containing element needed to have a negative <code>margin</code> in order to counter the side-effects of nested <code>margin</code> gutters.</p>

<p>The solution? <strong><code>flex</code> all the things.</strong> It became a question of who came first, the grid or the cell? The answer? Both. The container needed the <code>flex-direction</code> of a column, but the <code>align-items: center</code> of a grid. This finally centered my grid on the page, while enabling <code>margin</code> gutters, <code>calc</code>'d percentage widths and equal parallel cell heights.</p>

<h4 id="whyyoushouldntuseflexboxtomakeamorerobustbootstraplayout">Why you shouldn't use <code>flexbox</code> to make a more robust Bootstrap layout</h4>

<p>The grid we've constructed will work and it will give you the same fine-grain control you had over your Bootstrap grid before, but ultimately, it solves a very trivial problem.</p>

<p>A trivial problem which might cost perhaps 5%-10% of your possible users, depending on your target market, given the problems with <code>flexbox</code>. Yes, the trendy web design blogs are shouting about the incredible, universal adoption of the flexible box model, but in actuality, this is achieved by using a shed load of vendor prefixes (some of which reference behaviour that will definitely destroy your grid system) and then there's IE Edge, which, despite Microsoft's boasting, has yet to implement flexbox properly. </p>

<p>Sure, it might be fine for your personal website, but suggesting this to an e-commerce client will result in a pretty massive hit to your credibility. <code>float</code> works everywhere, and ensuring that your grid items are all the same height is not that difficult, especially when you're working with images and absolutely-positioned captions.</p>

<p>The correct way to use flexbox for grid systems is to use it for instances where the grid items are going to be of a uniform width. This is where flexbox can greatly simplify your code with <code>flex:1</code>. <a href="https://amdouglas.uk/leliel/" title="The Leliel Grid">You can see an example of flexbox being used to simplify the grid layout here</a>.</p>

<h4 id="waitforthecssgridmodel">Wait for the CSS: Grid Model</h4>

<p>I owe a big thank you to <a href="https://rachelandrew.co.uk/">Rachel Andrew</a>'s post on 24ways: <a href="https://24ways.org/2015/grid-flexbox-box-alignment-our-new-system-for-layout/"> Grid, Flexbox and Box Alignment</a> for making me wake up and smell the coffee. Layout should really not be controlled by many, many bytes of CSS classes. Flexbox already enables us to detox from the <code>.col-x-y</code> pattern and reduce our layout code to simply alternating <code>flex-directions</code> or <code>order</code> where necessary. </p>

<p>Not only that, but the proposed Grid spec is going to make grids even more trivial to setup than flexbox has enabled during its recent popularity spike.</p>]]></content:encoded></item><item><title><![CDATA[Future CSS Grids]]></title><description><![CDATA[<p>By now, if you're a frequent web trawler like me, you'll have come across articles discussing the new CSS Grid spec. The Grid is touted as a harbinger of an end to markup-dependent grid systems, like those offered by Bootstrap, Foundation, PureCSS, BassCSS, Bourbon Neat and so on. After reading</p>]]></description><link>https://amdouglas.com/future-css-grids-2/</link><guid isPermaLink="false">ebf5575f-ea97-4444-b379-694a1df0d663</guid><category><![CDATA[css]]></category><category><![CDATA[layout]]></category><dc:creator><![CDATA[A. M. Douglas]]></dc:creator><pubDate>Wed, 16 Dec 2015 20:59:59 GMT</pubDate><content:encoded><![CDATA[<p>By now, if you're a frequent web trawler like me, you'll have come across articles discussing the new CSS Grid spec. The Grid is touted as a harbinger of an end to markup-dependent grid systems, like those offered by Bootstrap, Foundation, PureCSS, BassCSS, Bourbon Neat and so on. After reading <a href="https://24ways.org/2015/grid-flexbox-box-alignment-our-new-system-for-layout/">this article </a> by the spec's lead developer and advocate, Rachel Andrew, I see that the future is much brighter thanks to <code>display: grid</code>.</p>

<h3 id="initialscepticism">Initial Scepticism</h3>

<p>Yes, I was very, very sceptical of the Grid spec, partially because of its exceptionally low level of support in even the latest browsers. I use Chrome 49 on my recreational computer and even then I can only see CSS Grid properties at work because one of the command line flags I run just happened to include Grid draft spec support.</p>

<p>Obviously the level of support will improve with time, but it's a powerful disincentive to actually giving the spec the time of day&mdash;I only gave flexbox a chance when support reached around 80%-85%, and it's not something I use in production. For clients, I'm all about <code>float</code> and <code>display: inline-block</code>.</p>

<p>Another reason for my scepticism was that the syntax looked, frankly, like more work and hassle for similar results.</p>

<h3 id="whataboutflexboxforlayout">What about Flexbox for layout?</h3>

<p>Some people looking at the Grid spec might question the use of it with respect to the fairly well-supported flexbox option.</p>

<p>I recently developed <a href="https://wnda.github.io/morag">a grid framework based on <code>display: flex</code></a>, and while it was relatively straightforward undertaking, and while it was a valuable exercise, I still couldn't help but find the end result a ugly. I couldn't help but find the possibilities of Flexbox being a little limited in some ways and a little overcomplicated in others.</p>

<p>Sure, the end result is a bit more versatile than traditional solutions, and Flexbox layouts are easily manipulated by switching between different flex-directions and align-items/align-self properties, but ultimately the basic form of the flexbox grid is equivalent to the same kind of grid achievable with <code>display: inline-block</code>&mdash;it's just a little bit easier to guarantee that the grid will look correct.</p>

<p>Of course, this comes at the cost of native browser support for some legacy clients, and that's actually not something that should be scoffed at. When you're actually working with businesses and service providers, your client is only the beginning of the story. You have to consider the end-user, and the end-user is not going to be running WebKit nightlies, Firefox Nightly edition or Chrome Canary.</p>

<p>Obviously everybody knows this, but the option to use the latest platform features is still here: you just need to conditionally load a bunch of polyfills&mdash;but I hate doing that.</p>

<h3 id="displaygrid">display: grid</h3>

<p>Originally, from a cursory glance of one or two examples, I saw nothing of value in CSS grids at all. The code appeared to be messy, less maintainable than present solutions.</p>

<p>I saw this CSS:</p>

<p><code>.wrapper {</code><br><code>display: grid;</code><br><code>grid-template-columns: 100px 10px 100px 10px 100px;</code><br><code>grid-template-rows: auto 10px auto;</code><br><code>background-color: #fff;</code><br><code>color: #444</code><br><code>}</code><br><br><code>.box {</code><br><code>background-color: #444;</code><br><code>color: #fff;</code><br><code>border-radius: 5px;</code><br><code>padding: 20px;</code><br><code>font-size: 150%</code><br><code>}</code><br><br><code>.a {</code><br><code>grid-column: 1 / 4; </code><br><code>grid-row: 1 / 2</code><br><code>}</code><br><br><code>.b {</code><br><code>grid-column: 5 / 6;</code><br><code>grid-row: 1 / 4</code><br><code>}</code><br><br><code>.c {</code><br><code>grid-column: 1 / 2;</code><br><code>grid-row: 3 / 4</code><br><code>}</code><br><br><code>.d {</code><br><code>grid-column: 3 / 4;</code><br><code>grid-row: 3 / 4</code><br><code>}</code></p>

<p>I may be subjective, you may even claim that I have bad taste, but nothing about this exemplary Grid CSS made me hungry for the spec. The warning lights began to flash immediately when I noticed that behaviour for each cell in the grid appeared to be defined precisely. </p>

<p>Now, if you're one of these developers who just feeds a bunch of crap CSS into a preprocessor and goes to lunch after delivering bloated, poorly understood code, maybe there's some build/task runner script that will automate this process, but I prefer to work with plain CSS and to establish high-level behaviours which <strong>cascade</strong> down, rather than micromanage every element in my web page.</p>

<p>So I ignored the Grid spec. I kept using traditional grid system patterns and eventually dabbled with Flexbox. That is, until today, when I had a read of the aforementioned article by Rachel Andrew.</p>

<p>There, I saw code like this:</p>

<p><code>.wrapper {</code> <br>
<code>display:grid;</code> <br>
<code>grid-template-columns:repeat(12,12fr);</code> <br>
<code>grid-template-rows:auto</code> <br>
<code>}</code></p>

<p>That's a 12 column grid in 5 lines of CSS. Each of those columns will be sized exactly, and you can add gutters in a similarly precise way. </p>

<p>5 lines per media query (instead of redefining a <code>.col-[x]-[y]</code> for every breakpoint).</p>

<p>What's more, for those times where you need bigger grid cells and yet still need a general grid cell size/structure (think: featured products, product categories by popularity, etc.) you can define a particular grid cell size and the grid will essentially take care of the bin-packing for you, thanks to this beauty:</p>

<p><code>grid-template-rows:auto</code><br></p>

<p>The Grid spec is going to revolutionise responsive web design. It's going to be trivial to establish mobile layouts and HTML will never have been so lean.</p>

<h3 id="epilogue">Epilogue</h3>

<p>My advice to web developers approaching Flexbox is this: wait for the Grid to land in popular browsers. Stick to <code>display: inline-block</code> or <code>float</code> for grids. I know it's horrible, but it's the best thing you can do for your users at the moment.</p>

<p>If you must upgrade, don't <strong>require</strong> Flexbox. Offer it as a progressive enhancement; but know this: you really can't offer <strong>significant</strong> advantages with it. There's nothing that Flexbox can do that cannot be done with <code>position: absolute</code>, <code>float</code> or <code>display: inline-block</code>.</p>

<p>Flexbox makes some of these tasks simpler, and it may allow you to tidy your markup a bit, but its nothing compared to what the Grid spec will offer when it lands.</p>

<p>Be patient. Refine your tried-and-tested, robust (if old-fashioned) code. If it isn't broken, don't fix it. Spend some time using other browsers as your daily driver. It's insufficient to just check every now and again. You need to be aware of the little nuances, like trying to center Flexbox elements with <code>margin:0 auto</code> in Safari. Protip: it works in Chrome, Firefox, IE11... and not in Safari.</p>]]></content:encoded></item><item><title><![CDATA[You Might Not Need Masonry]]></title><description><![CDATA[<p>Masonry. It's the drop-in answer to the variable-content grid problem (<strong>a grid that will accommodate post excerpts/images of varying heights</strong>). It works. It works in pretty much all browsers that you should realistically give a crap about (yeah, even IE8). It's even available in pure JavaScript (for those performance</p>]]></description><link>https://amdouglas.com/you-might-not-need-masonry/</link><guid isPermaLink="false">f6c5b070-37ad-44ab-ba6b-ef0780fc3e7a</guid><category><![CDATA[css]]></category><category><![CDATA[layout]]></category><dc:creator><![CDATA[A. M. Douglas]]></dc:creator><pubDate>Mon, 14 Dec 2015 13:50:42 GMT</pubDate><content:encoded><![CDATA[<p>Masonry. It's the drop-in answer to the variable-content grid problem (<strong>a grid that will accommodate post excerpts/images of varying heights</strong>). It works. It works in pretty much all browsers that you should realistically give a crap about (yeah, even IE8). It's even available in pure JavaScript (for those performance nuts out there, like myself, who take issue with things like jQuery in 2015).</p>

<p>Now, many have sang the praises of Flexbox for its amazing properties and the ease with which previously complex layouts can be built with surprising simplicity, but this is far from a native answer to Masonry.</p>

<p>The problem is that, for CSS to emulate Masonry behaviour, it would need to be aware of itself, which it isn't. Your <code>.col-whatever</code> has no idea what height it is, and it only knows its width because you gave it a width in order to create a grid. You could give it a height, but that would defeat the purpose; either you end up with a classic grid or you end up reinventing the same JavaScript plugin you're supposed to be avoiding.</p>

<p>There is, however, two perfectly simple alternative ways to achieve a Masonry layout.</p>

<h3 id="considerthefollowing">Consider the Following</h3>

<p>The first is a very much overlooked feature of CSS3. Welcome to CSS3 Columns.</p>

<p>So, how does it work? Therein lies the rub. CSS3 Columns would be be perfect, even surpassing Flexbox and the hotly anticipated Grid spec, if not for the minor drawback that it works in the same way as newspaper columns. A column drags on for as long as its content, wrapping to the next column. Oh, yeah, almost forgot: no rows, just columns snaking their way from left to right. Very disorienting.</p>

<p><strong>What is it good for?</strong></p>

<ul>
<li>Tumblr themes</li>
<li>Media galleries</li>
<li>Personal portfolios</li>
<li>Anything where an intuitive display of a sequential or chronological order is not needed</li>
</ul>

<p><strong>When to avoid?</strong></p>

<ul>
<li>Pretty much any other time</li>
</ul>

<h3 id="flexbox">Flexbox</h3>

<p>Ever since I first looked at the Flexbox spec, I have thought &ldquo;this is <strong>it</strong>, no more JavaScript for layouts&rdquo;&mdash;and though I've yet to crack the JS-less Masonry layout, I have come up with something which might just fit the bill for many Masonry users.</p>

<p>Masonry can pretty much cope with anything you through at it. Mixed widths, heights, anything. It positions elements absolutely within a relatively positioned container and this makes it extremely powerful. Some choose Masonry because it's the look that they want. It's so iconic in Pinterest's UI that many think Pinterest invented or put their name to the concept. You'll be hard-pressed to find a photography-focused Tumblr theme which doesn't use Masonry or an equivalent.</p>

<p>But what about all the other users? Business/marketers who just want to post content and let the layout decide how it should appear? Who want to target users on mobile effectively (yes, that means <strong>as little JavaScript as possible</strong> people, calm down on the JavaScript everywhere thing). </p>

<p>If flexbox can size items according to their immediate neighbours, and if it can alternate between row and column display directions, and if we have tools like <code>calc</code>, surely it's possible to concoct a good-enough layout without programming?</p>

<p>The answer is yes. It comes in the form of a humble grid system, but nothing as temperamental or brittle as Bootstrap. This grid was made to be abused.</p>

<h3 id="introducingmoragcss">Introducing: Morag.css</h3>

<p>Mòrag is a Scottish name; a diminutive form of Mòr, the Scottish Gaelic for &ldquo;great&rdquo;.</p>

<p>The Morag grid is one of my own design, emerging from a long-running frustration with <code>float</code> and <code>inline-block</code> based grids which do not adapt to suit content unless the content is of a fixed width and height. So, already, my grid has sprung from a similar goal to that of the Masonry solution, though the two ultimately differ in terms of aesthetics.</p>

<p>I find Pinterest reasonably attractive to look at, but it's getting a little bit too popular. Masonry layouts are unsurprisingly less friendly to consume than a calmer, level field when it comes to text. The Morag grid keeps everything level while covering up those offensive gaps and tidying up where your content items are insufficient or excessive in terms of cell-breadth.</p>

<p><a href="https://wnda.github.io/morag">Have a poke around with the grid and see what you think.</a></p>]]></content:encoded></item><item><title><![CDATA[Conditional CSS]]></title><description><![CDATA[<p>Performance should always have been important, but it is finally being taken seriously as competition for web supremacy stiffens. We're beyond simply tidying up websites which were cobbled together by an intern and made 100+ requests for jQuery plugins and thoughtlessly included stylesheets/fonts&mdash;now we need to optimise</p>]]></description><link>https://amdouglas.com/conditional-css/</link><guid isPermaLink="false">fcccb485-cb61-49b7-a5bf-f0d617bc0a34</guid><category><![CDATA[css]]></category><category><![CDATA[performance]]></category><dc:creator><![CDATA[A. M. Douglas]]></dc:creator><pubDate>Mon, 14 Dec 2015 12:39:10 GMT</pubDate><content:encoded><![CDATA[<p>Performance should always have been important, but it is finally being taken seriously as competition for web supremacy stiffens. We're beyond simply tidying up websites which were cobbled together by an intern and made 100+ requests for jQuery plugins and thoughtlessly included stylesheets/fonts&mdash;now we need to optimise to the extreme. Anything blocking the rendering of your web page should be your enemy. </p>

<p>You basically have two options: either you wait for HTTP/2 and multiplexing, or you flex and accommodate for HTTP/1 for the time being. I want to show how I work with embedded/inline CSS to keep my code lean on HTTP requests and at the same time extremely manageable.</p>

<h4 id="theusecase">The Use Case</h4>

<p>If you're working with a modern CMS (like Ghost/Handlebars.js), you can use partials to create server-side 'components' to keep the globally-required CSS to an absolute minimum. Just include the embedded CSS for the component above the component's actual markup and include the partial where it is required. This is something that can easily be replicated and even automated by nesting and collating partials depending on the size and complexity of your website.</p>

<p>Now, I am sure you're screaming at your screen saying something like &ldquo;that's extremely inefficient, you'll load CSS for every instance of a repeated element when it's only needed once&rdquo;&mdash;and you're absolutely correct, but that is not what I am suggesting you do. You should of course use the strategy I am proposing in a way that best suits your website, and you should avoid thinking that a grid-cell is a component; a parentless grid is a component.</p>

<p>Traditionally (or lazily/when working to a deadline) a website will have a great big CSS file loaded in the head (or several moderately-sized CSS files depending on the silliness of the developer) which comprises styling information for every page of the website. In this file, you'd have rules for everything, from the navigation bar and buttons used on every page to lightbox/carousel styles used only in specific places.</p>

<p>Perhaps one day in the not-so-near future, we won't need stylesheets, and instead every component on a website will be a self-contained <code>document</code> containing style rules scoped to the component as well as component-specific data-bindings and so on. This is the aim of the Web Components spec and the Polymer Project, and is also marketed as a natural by-product of working with React (though they differ in a few key regards, the details of which might form the subject of a future blog post).</p>

<p>However, Web Components are a polyfilled pipe dream and React.js is a massive inflation of complexity (and a needless performance hog) for <strong>simple</strong> websites. As a web developer working at a design agency, the vast majority of my time is spent making promotional/brochure websites, which are, for all intents and purposes, static. Sometimes dynamic interaction/functionality is called for, but not enough to necessitate anything more than a few lines of native JavaScript.</p>

<p>Rarely do I get assemble something like a single-page-application, and the bottom line is that React.js, like jQuery, is unnecessary in these glorious ES5/ES6 days. Such libraries would only make my workflow more complex and my websites slower. The useful abstractions libraries and frameworks provide are simply wasted on me.</p>

<p>So, since there is no native solution to compartmentalise web development in the browser, and since JS frameworks are <strong>not</strong> worth the headache on simple projects where good design and device agnosticism are the primary boxes to tick, how does one break out of that render-blocking mess in the <code>&lt;head&gt;</code>?</p>

<p>The answer is to take proper advantage of your CMS. I like to work with Handlebars&mdash;it's simple and clean and does the job, but Mustache or Twig will do just as well. You're probably seeing where I'm going with this, and perhaps yelling <strong>&ldquo;but browsers don't even honor the <code>scoped</code> attribute on inline styles!&rdquo;</strong></p>

<p>I'm not suggesting that components be built using templates. This sort of pattern was one way to work with ASP.NET WebForms (simply create a UserControl and drop wherever you need it&mdash;unsurprisingly not much fun to do) and it's not what I am suggesting.</p>

<p>No, all we want to do is:</p>

<ul>
<li>Constrain how much CSS is loaded in the <code>&lt;head&gt;</code> and potentially on a per page basis</li>
</ul>

<p>To do this, we really just need to inline CSS which governs how content <strong>above the fold</strong> appears, and subsequently do one of two things:</p>

<ul>
<li><p>declare the remainder of your styling information in inline segments (if your project is simple, this is a pretty cool way to break your CSS down into manageable, &lsquo;componentised&rsquo; pieces without using the dreaded <code>@import</code>)</p></li>
<li><p>load your external stylesheet asynchronously (use JavaScript)</p></li>
</ul>

<p>Being a performance-crazed developer, I include embedded CSS according to template context. Either way you'll want to start writing your CSS in a modular and well-structured way, ideally so some fundamental rules are established globally in the inline style you load in the <code>&lt;head&gt;</code> which then cascade down and influence your elements below the fold. This is where things like proportional units come in handy. </p>

<p>Non-shitty CSS is a necessity. A highly technical term, non-shitty CSS refers to CSS where the cascade in &ldquo;<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets&rdquo; is actually used, rather than having a class for every component type, state or event. It also refers to CSS where you don't unnecessarily repeat yourself with some robotic BEM naming scheme, or bloat your code base with preprocessor abuse.</p>

<p>It also requires that you either use your preprocessor with due caution. Or you could do the right thing and get rid that unnecessary layer of complexity. Use Ctrl+F for your color changes like a rational person, and damn it if you struggle to keep track of the HEX codes for the colors you use for disabled/hover states, use <code>rgba</code> or <code>hsla</code> and modify one number.</p>

<h3 id="whyisntthisstandardpractice">Why isn't this standard practice?</h3>

<p>Simple. Having a whopping great external CSS file loaded in the <code>&lt;head&gt;</code> is &ldquo;easy to maintain&rdquo; and &ldquo;manageable&rdquo;. I personally disagree with this sentiment. First of all, why should we developers be looking for the easiest ways of doing everything? While certain principles guide us on the path to excellent software design (DRY, for instance) the easy path cannot always be the <strong>right</strong> path. </p>

<p>It is the cost-effective path, but consider the benefits for the user and that there are always methods to simplify and automate development processes if there is sufficient impetus. Personally, I think the performance gains from shedding page weight and unnecessary HTTP requests (for HTTP/1.1) are worth it. Loading CSS in template blocks also helps to provide some scope to styling which was on the roadmap in the new HTML5 spec before Google essentially (and rightly) harpooned it due to the complexity spike involved.</p>

<h3 id="closingremarks">Closing remarks</h3>

<p>You have to be careful to keep your partials comprehensible. It is especially easy in WordPress or some other archaic CMS to make things look messy. Naming your template partials clearly is crucial, as with any development workflow.</p>

<p>Knowing how and what to divide into separate template partials is also a key to maintaining a manageable workflow. Not every line needs to be a partial, just blocks of CSS which are needed on specific pages and not everywhere. A global partial containing ubiquitous styling rules is a necessity, and much of this you can inline in the <code>&lt;head&gt;</code> to avoid the FOUC. Other rules can be added in the <code>&lt;body&gt;</code>. However, the performance benefits gained by cutting out render-blocking resource requests is very much worth it if you care at all about that sort of thing (hint: you should).</p>

<p>There is, of course, the issue of caching. I find it very amusing that many content management systems actually prevent proper caching by appending version numbers as querystring parameters to external resources, and if you can show me a web host that enables proper caching HTTP headers with Apache/nginx, I'll show you a web developer who likes PHP. The point: inline styles are not cached, but then again, neither are external stylesheets in many cases, so what are you losing? You're rather more likely to gain from removing one more HTTP request from your page load.</p>

<h4 id="addendumregardingstylescoped">Addendum: Regarding <code>&lt;style scoped&gt;</code></h4>

<p>I do understand why the Chrome devs dropped this feature. Shadow DOM removes the need for it and DOM complexity would increase dramatically if you have to track element parents for style rules as well as externally loaded stylesheets, global inline-styles AND attribute styles.</p>]]></content:encoded></item><item><title><![CDATA[Abstracting the DOM]]></title><description><![CDATA[<p>Summary: neither of these solutions can be considered performant. On the one hand, you're loading dozens of resources for shadow DOM trees; on the other, you've got an in-memory copy of the entire DOM. Both methods presume some arguably unfair minimum requirements.</p>

<p>As Google continues to push for the Web</p>]]></description><link>https://amdouglas.com/abstracting-the-dom/</link><guid isPermaLink="false">cd068ac4-8467-44f8-bab8-80aeeeb8b4e3</guid><category><![CDATA[javascript]]></category><dc:creator><![CDATA[A. M. Douglas]]></dc:creator><pubDate>Thu, 03 Dec 2015 23:22:27 GMT</pubDate><content:encoded><![CDATA[<p>Summary: neither of these solutions can be considered performant. On the one hand, you're loading dozens of resources for shadow DOM trees; on the other, you've got an in-memory copy of the entire DOM. Both methods presume some arguably unfair minimum requirements.</p>

<p>As Google continues to push for the Web Components standard&mdash;even roping in its puppet-competitor Mozilla&mdash;and while Facebook's React.js continues to grow in its influence and maturity, an important question arises which will be significant in determining the likely victor between these related technologies: which is better, the shadow DOM or the virtual DOM?</p>

<p>It's necessary for us to first establish what each of these actually is in order to make an informed judgement on which is better. The shadow DOM is one of the concepts that is driving the push for the Web Components standard. It's not strictly necessary to use a shadow DOM for a Web Component, except that what you have then is not really a Web Component, but a <code>custom-element</code>.</p>

<p>A Web Component is a set of DOM elements packed as an isolated and portable block, with its own style/script context, separate from the &ldquo;true&rdquo; DOM. We call this isolation of styling/scripting <strong>encapsulation</strong> and it's very attractive over the incumbent iFrame, a noted performance hog. Take out the shadow DOM, aka the diet iFrame, and you have a custom element, literally HTML elements for which you can provide custom tag names&mdash;basically, a means by which to take the notion of semantic DOM nodes to the extreme.</p>

<p>Sure, it's nice to have semantically-named UI components as clean blocks that you can essentially copy and paste into the <code>document</code>, but the performance cost is astronomical in Safari and Firefox with all of the polyfills, and it's no spring chicken in Chrome compared to regular HTML.</p>

<h3 id="react">React</h3>

<p>Facebook's React.js promises similar modularity of components, but without the expense of performance. In fact, performance is alleged to see an improvement thanks to its 'virtual DOM', literally a JavaScript object which serves to centralise UI state. </p>

<p>The performance improvement over other frameworks results from the virtual DOM not actually being a rendering engine, it's essentially version control for the native DOM. Change something and, rather than rewrite the DOM, it tracks the changes and updates (hence the name &ldquo;React&rdquo; rather than &ldquo;jQuery 3&rdquo;) and this should, in theory, keep costly DOM manipulation to a regulated minimum.</p>

<p>And it's true, React is a nimple alternative to frameworks like Angular, but this is a common misinterpretation of what React is and what other frameworks are. Angular, and Polymer to an extent, <strong>are ASP.NET WebForms reimagined</strong>, while React is a diffing algorithm and an abstracted handler for UI state. <a href="http://hackflow.com/blog/2015/03/08/boiling-react-down-to-few-lines-in-jquery/" title="Boiling React Down to a Few Lines in jQuery">You can even implement React's benefits in jQuery</a> if you don't like how React does things, or you could roll your own framework adopting React's <strong>approach</strong> rather than getting tangled up in the React fad of using JSX, attribute styles, and so on. The core ideal of delta copying, of tracking revisions to the DOM, is (or should be) the (only) reason behind React's prevalence in recent months.</p>

<h3 id="applesandoranges">Apples and Oranges</h3>

<p>You should see by now that the shadow DOM and the virtual DOM are basically incomparable, or at least that to compare them is to take them out of the context of what they are intended to achieve, despite often being mentioned in the same sentence when developers are comparing the latest JavaScript framework flavours of the month that they want to evangelize. </p>

<p>Minimising/abstracting DOM revisions and separating the DOM into lots of sub-DOMs are different solutions to different problems. Eventually, Web Components/Polymer will probably end up taking some concepts from React on board and do away with DOMs within DOMs (seriously, they removed support <code>&lt;style scoped&gt;</code> from Chrome due to complexity, but nesting a different DOM context for every major UI component is supposed to be simpler?</p>

<h3 id="shouldibeinterestedinanyofthese">Should I be interested in any of these?</h3>

<p>I mean, it depends on your requirements, how good you are at writing portable vanilla JavaScript, and whether you're part of a vanilla-compatible team. I'm with Google's AMP-HTML team when it comes to the vast majority of websites on the internet: you do not need a web application to serve articles to readers. </p>

<p>JavaScript has been heavily abused to serve people obnoxious-yet-profitable advertisements for years, starting at first with low-level, native functions like <code>alert</code> and these days creating modals and overlays block users from consuming content without first doing something profitable.</p>

<p>JavaScript should, for most of these websites, be reserved for basic or <strong>necessary</strong> functionality. What do I mean by necessary? I mean not even form validation. Don't even talk to me about form validation. For starters, validation only makes sense server-side, where the user cannot switch the validation of. </p>

<p>Even if, for the sake of good UX, you want to give some immediate (i.e. not post-<code>post</code> or post-reload) feedback regarding the validity of user input, you can&mdash;and should&mdash;validate on the client side using <strong>HTML5 attributes</strong> like <code>pattern</code> and <code>required</code>, along with <code>:valid</code> or <code>:invalid</code> CSS3 selectors to indicate state. </p>

<p>The most you could possibly need on the client side for polished UX would be an <code>onblur</code> handler to throw into the mix.</p>

<h3 id="whywebcomponentsarecrazy">Why Web Components are crazy</h3>

<p>Scope is nice and everything, but just watch the network timeline for a Polymer site. HTTP2 is coming soon, but not <strong>that</strong> soon. Sure, you can hit up the Polymer Project website and not find yourself waiting around too long, but that's probably thanks to much of the website's resources being served up by Google's CDN. </p>

<p>The reality is that serving up a Polymer app will incur some performance penalties on the HTTP1 spec, and they're just not worth it. Encapsulation basically enables lazier development with little to no gain for the user. There is enough front-end tooling available to trivialise the production of optimised clean, modular CSS. Write your CSS properly and you shouldn't <strong>need</strong> encapsulation.</p>

<p>Additional DOMs aren't necessarily horrendous for performance in and of themselves, and they might simplify tracking your app's behaviour, but if you're aiming for isomorphism you can kiss these shadow DOMs goodbye. Do without isomorphism and clients with JavaScript switched off or with no JavaScript at all won't actually see a website. </p>

<p>It is true that the number of clients lacking JavaScript is, well, pretty low these days&mdash;chances are the users who switch JavaScript off or who use Lynx probably won't be your target demographic/niche anyway. However, you've still the FOUC to consider if you opt out of isomorphism. And then there's stale-copying/caching/offline support to think about. Seems like a helluva lot to cache.</p>

<p>In my opinion, the whole point of the web and the reason for its use as an app vector orthogonal to native apps is:</p>

<ul>
<li>The web should be light</li>
<li>The web should be trustworthy</li>
<li>The web should be universal/cross-platform</li>
</ul>

<p>When you start thinking about Web Components and offline web apps, you're really not far from just installing a native app. It'll be heavier than a website should be, it'll need to essentially install itself or a copy in order for it to work offline, and the complexity of the web app itself and the development time will likely skyrocket. Plus Web Components are only natively supported in Chrome, which means that the Web just stopped being cross-platform which is its singular <strong>financial</strong>/<strong>business-translatable</strong> advantage over native apps. </p>

<p>And then there is an issue of trust: where are you getting your components from? JavaScript/jQuery plugins are one thing, but now entire components and eventually page models? And what APIs will these web apps start to access, how much privacy will they start to invade?</p>

<h3 id="whyyoustillshouldntconsiderreact">Why you <em>still</em> shouldn't consider React</h3>

<p>Thanks to its render method and virtual DOM, React.js is pretty much the only sane approach for reusable HTML components. It's also the only sane approach for nesting said components. However, unless you really need a JavaScript MVC framework and thence a React view layer, my suggestion is leave it the hell alone. </p>

<p>Write lean, clean HTML5, write elegant CSS3, and add <strong>a dash</strong> of vanilla JavaScript if/when it is necessary. Recognise your use-case and don't waste time thinking about some fancy thing you heard about. All JavaScript use comes with a cost to performance on mobile. I write browser-native JS as much as I can but DOM manipulation is <strong>always</strong> costly. </p>

<p>I mean, you do get something of a budget on modern smartphones, and having Chrome available on iPhone and Android is a big help, but you have to remember that just because Chrome is the rational browser choice, that does not mean that it will be the browser of choice for the majority of users. It won't be.</p>

<p>Oh and don't trust React's virtual DOM to save you from the performance cost of DOM manipulation. The virtual DOM isn't an infinitesimal or a nearly massless neutrino; it is part of a UI library, so add a HTTP request. Then do some intensive DOM manipulation with the virtual DOM.</p>

<p>Sure, it might seem like it's more performant in the beginning, but as time and manipulation go up, the vDOM's powers go down. Don't forget, it works by bundling manipulations and dumping them on the DOM in one go, which means at some point it's guaranteed to bottleneck where native JavaScript won't.</p>

<p>(In all fairness, you can hardly blame iOS users for sticking with Safari since you cannot change the <strong>default</strong> browser, just install additional ones, making Chrome a bit of a hassle to use if you need to open a link from within an app or email.)</p>

<p>If somebody comes to you with some serious money, a sane deadline that permits for extensive testing and a desire for a performant web app, then you can think about React.</p>

<h3 id="isomorphism">Isomorphism</h3>

<p>NB: if you must opt for an SPA, please use React and render it on the server. Angular 1.* is dead and Angular 2.* is still going to be Google WebForms. Sure, it works, but if the alternatives are lighter, cleaner, and quicker to develop (once you achieve a reasonable level of proficiency) things like Angular really start to make less sense.</p>

<h3 id="thefuture">The Future</h3>

<p>Lots of developers should be thinking about these technologies and approaches to the web. Native apps are a serious threat to the future of the web and web applications need to be demonstrably equal to or better than native applications in more ways than relative cheapness. Web applications need offline support, high performance, high framerate, real-time notifications and so on. All of these are possible, but with varying degrees of success/stability. </p>

<p>With businesses developing mobile apps just for user engagement, without having any function or service in the app, it's clear that users just like apps and to interact. Suffice it to say that, if performant native apps were written in a common language and thus costed less to develop, the web would not have time to respond. We web developers ought to actually thank Apple, Google and Microsoft for adopting Objective-C, Java and C#.NET respectively.</p>]]></content:encoded></item><item><title><![CDATA[The Pursuit of Perfection]]></title><description><![CDATA[<p>Damn, we're a dot-com now! Yes, thanks to <a href="https://www.namecheap.com/">Namecheap's</a> Black Friday sale on .com domains, I couldn't resist moving up in the world from <a href="http://www.dotuklaunch.uk/">the barely known <strong>.uk</strong> domain</a>, which doesn't make for a great email address as it sometimes causes websites with badly-implemented form validation to trip up.</p>

<p>It</p>]]></description><link>https://amdouglas.com/the-pursuit-of-perfection/</link><guid isPermaLink="false">9bdc2e62-cc08-4f12-9ed8-0f1c4489b8cf</guid><category><![CDATA[unix]]></category><category><![CDATA[server]]></category><dc:creator><![CDATA[A. M. Douglas]]></dc:creator><pubDate>Tue, 01 Dec 2015 13:38:00 GMT</pubDate><content:encoded><![CDATA[<p>Damn, we're a dot-com now! Yes, thanks to <a href="https://www.namecheap.com/">Namecheap's</a> Black Friday sale on .com domains, I couldn't resist moving up in the world from <a href="http://www.dotuklaunch.uk/">the barely known <strong>.uk</strong> domain</a>, which doesn't make for a great email address as it sometimes causes websites with badly-implemented form validation to trip up.</p>

<p>It also struck me that the new domain presented a good opportunity to review this website's implementation in general. Previously built on Linux, nginx and Node.js/Express.js, the website was already able to cope with pretty much any network load it was likely to experience. Lots of people blame Linux when their web applications fail to scale, but this will almost undoubtedly be down to their own poor configuration of their Linux distro.</p>

<h3 id="whatsnew">What's New</h3>

<ul>
<li>FreeBSD!</li>
<li>HTTP/2!</li>
<li>New contact form with Nodemailer!</li>
<li>True responsive typography!</li>
</ul>

<h3 id="roadmap">Roadmap</h3>

<ul>
<li>Redis</li>
</ul>

<h3 id="movingtofreebsd">Moving to FreeBSD</h3>

<p>As part of my ongoing journey to reach performance perfection, I have taken the opportunity of the Black Friday weekend to reimplement my website using FreeBSD, retaining Node/Express, SQLite and nginx. The reasons for this have emerged over a period of time subjecting both Linux and FreeBSD servers to a fair bit of testing, both as an administrator/developer and as a visitor.</p>

<p>As a developer who made a start to their career in the late 90s and in the United Kingdom, my first exposure to computers involved Windows. I soon grew rather tired of its limitations in terms of building <strong>new</strong> things, and it wasn't long before I was searching for alternative operating systems. I remember waiting over a period of days for my first Slackware disc image to download. Suddenly, I discovered the UNIX playground. </p>

<p>Slackware is not pure UNIX, but it's as close as a Linux distribution has ever gotten and will likely ever get, since these days Linux rather walks its own path (think about Ubuntu and Android, and even ChromeOS&mdash;not exactly the direction envisaged by UNIX developers). </p>

<p>I spent (some might say wasted) a lot of time learning how to optimise Slackware (and later Gentoo) for performance down to the millisecond thanks to hardware-specific tuning and I found that Linux operating systems offered a much more robust networking platform than anything Microsoft offered. There was also the not insignificant matter of the price tag on the Windows Stack).</p>

<p>It wasn't long after my tinkering with Linux that I found myself developing websites, at first trying (and failing) to build a content-management system in bash and turning to Perl, and soon Perl gave way to PHP (which I thoroughly dislike but continue to use). I never really took the time to get to acquainted with a BSD/UNIX OS. I wanted to change that, not least because FreeBSD has the almighty <code>ports</code> system, which gives you the freedom to upgrade software without upgrading your OS. Very handy if you give a damn about uptime.</p>

<h3 id="whatsnottolike">What's not to like?</h3>

<p>The primary advantage to which I can personally testify is the <code>ports</code> system. There are many claims to the superiority of the BSD network stack, but I think these claims are a little out of date. Contemporary Linux systems might have a more aggressive life cycle but that has resulted in its networking advancing ahead of FreeBSD in terms of throughput.</p>

<p>I will document my experiences with FreeBSD as I go along, but so far it's been much quicker to set up the kind of environment I like to work in: hardened security, long-life system which doesn't require regular updating and in which upgrading packages doesn't instill a slight fear of a system crash.</p>

<p>Another great benefit of FreeBSD? ZFS. This is a file system which, as its name suggests, can handle <strong>zettabytes</strong> of data. I/O is biased towards reads over writes, meaning that writes do not block reads and random I/O operations are grouped into sequences, resulting in better I/O performance. </p>

<p>And, of course, no discussion of ZFS would do the file system justice without mentioning its superb snapshot capabilities&mdash;where FreeBSD is already the most robust and reliable server OS you can find, ZFS's essentially limitless snapshot capability make it trivial to recover data.</p>

<p>So far, performance appears to be better, but I chalk that down to a revised page load waterfall and, of course, HTTP/2.</p>]]></content:encoded></item><item><title><![CDATA[On AMP-HTML]]></title><description><![CDATA[<p>A recent exercise which partially motivated my recent overhaul of my already overhauled website was the adoption of Google's AMP-HTML standard for blog/primarily-text-based content delivery.</p>

<p>Google essentially offers a free CDN as long as you hand over the ignition keys to JavaScript&mdash;that's right, no JavaScript. Fortunately, I</p>]]></description><link>https://amdouglas.com/on-amp-html/</link><guid isPermaLink="false">f621db63-38b6-48d2-a050-4f23ea439e84</guid><category><![CDATA[amphtml]]></category><category><![CDATA[performance]]></category><dc:creator><![CDATA[A. M. Douglas]]></dc:creator><pubDate>Sun, 25 Oct 2015 20:24:00 GMT</pubDate><content:encoded><![CDATA[<p>A recent exercise which partially motivated my recent overhaul of my already overhauled website was the adoption of Google's AMP-HTML standard for blog/primarily-text-based content delivery.</p>

<p>Google essentially offers a free CDN as long as you hand over the ignition keys to JavaScript&mdash;that's right, no JavaScript. Fortunately, I like to keep JS to a minimum for web<em>sites</em>, so I'll be able to get around it using procedural tricks with radio buttons and CSS pseudo-selectors!</p>

<p>Oh dear. All input fields except <code>button</code> are banned. As are most CSS3 pseudo-selectors. And CSS3 transitions/animations.</p>

<h3 id="workingaroundamp">Working around AMP</h3>

<p>Nothing is impossible in this trade. While you can't use input fields to masquerade as dynamic interactive components using the label substitution trick, you can make use of Google's custom elements like <code>amp-lightbox</code> which you can include as many times as you like and are free to style (though you can't use the <code>-amp-*</code> class in your CSS selectors, you can add an <code>id</code> to target it without throwing up a validation issue.</p>

<h3 id="aegrescitmedendo">Aegrescit medendo</h3>

<p>Originally I had intended to make my whole website using AMP-HTML, as JavaScript is something I tend not to include when simple effects and animations can be achieved with CSS3, yet Google's AMP implementation requires JavaScript. True, Google's JavaScript is probably going to be more efficient than some have-a-go-hero's jQuery plugin (PSA: please stop using jQuery everywhere) but if you don't actually need JavaScript, opting for the AMP standard for the sake of a CDN is unlikely to do you any real favours.</p>

<h3 id="doyouneedacdn">Do you need a CDN?</h3>

<p>It didn't take me long to realise that my website really, <strong>really</strong> doesn't need a CDN, because firstly the content I make is not delivered to anybody,and secondly, if it were, it would most likely be to people in the UK or worst case scenario, within the EU.</p>

<p>Before I implemented AMP-HTML, my website scored perfectly on Google's PageSpeed Insights for both mobile and desktop; using AMP-HTML, it scored something like 95%. No surprise! The page downloaded a few unnecessary scripts, whose function it is to primarily forbid the downloading of other scripts and to load custom elements should you make use of them.</p>

<p>I will go on the record as saying that the amp-components are lightweight and work delightfully well independent of each other&mdash;I could quite happily load the elements asynchronously without any perceptibly detrimental effect on page load performance. But it was still an annoyance to actually sacrifice some performance when I was hoping to improve it.</p>

<h3 id="theusecase">The use case</h3>

<p>AMP-HTML simply does not apply to your personal websites, your blogs etc. It <strong>might</strong> find a use if you primarily serve images that ought to be loaded asynchronously and ideally via CDN, but if not, and if you're not a major news media outlet, AMP-HTML is not necessary. Just keep your markup clean and limit your JavaScript use as much as possible. </p>

<p>If you think you need JavaScript to make animations, please learn about CSS properly. If you think you need jQuery to do what JavaScript can do natively, please learn about JavaScript properly. If you don't care about page load performance, please learn about web development properly.</p>

<h3 id="newdesign">New design!</h3>

<p>So in response to the almost immediate desire to un-AMP my website, I decided it needed a redesign anyway, something more friendly to some older devices (like a BlackBerry I recently received from a friend as an unwanted antique) and something that could showcase my <a href="https://wnda.github.io/morag">morag CSS grid system</a> and help debug it in the wild.</p>

<p>So here we have it: just about as gridtastic as a website could be. My roadmap still includes the following:</p>

<ul>
<li>A color scheme</li>
<li>A decision on hard or soft box-shadows</li>
<li>Some animation/transitions for hover effects</li>
<li>Possibly remove margin separation from grid for this case</li>
*
</ul>]]></content:encoded></item></channel></rss>
